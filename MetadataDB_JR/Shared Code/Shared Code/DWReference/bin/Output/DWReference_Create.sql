/*
Deployment script for DWReference

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "DWReference"
:setvar DefaultFilePrefix "DWReference"
:setvar DefaultDataPath ""
:setvar DefaultLogPath ""

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)] COLLATE SQL_Latin1_General_CP1_CI_AS
GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY SIMPLE,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY NONE,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
USE [$(DatabaseName)];


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
GO

GO
PRINT N'Creating [BRIGHTSTAR\APACDB_DBA_S]...';


GO
CREATE USER [BRIGHTSTAR\APACDB_DBA_S] FOR LOGIN [BRIGHTSTAR\APACDB_DBA_S];


GO
REVOKE CONNECT TO [BRIGHTSTAR\APACDB_DBA_S];


GO
PRINT N'Creating [BRIGHTSTAR\AMarret]...';


GO
CREATE USER [BRIGHTSTAR\AMarret] FOR LOGIN [BRIGHTSTAR\AMarret];


GO
REVOKE CONNECT TO [BRIGHTSTAR\AMarret];


GO
PRINT N'Creating [db_executor]...';


GO
CREATE ROLE [db_executor]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating <unnamed>...';


GO
EXECUTE sp_addrolemember @rolename = N'db_datareader', @membername = N'BRIGHTSTAR\APACDB_DBA_S';


GO
PRINT N'Creating [Audit]...';


GO
CREATE SCHEMA [Audit]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [dbo].[ScheduleType]...';


GO
CREATE TABLE [dbo].[ScheduleType] (
    [ScheduleTypeID]   INT           IDENTITY (1, 1) NOT NULL,
    [ScheduleTypeName] VARCHAR (100) NULL,
    CONSTRAINT [PK_ScheduleType] PRIMARY KEY CLUSTERED ([ScheduleTypeID] ASC)
);


GO
PRINT N'Creating [dbo].[SummaryControl]...';


GO
CREATE TABLE [dbo].[SummaryControl] (
    [SummaryControlID]              INT            IDENTITY (1, 1) NOT NULL,
    [SummaryPackageName]            VARCHAR (100)  NOT NULL,
    [SummaryPackagePath]            VARCHAR (100)  NULL,
    [SummaryTableName]              VARCHAR (100)  NULL,
    [ScheduleType]                  VARCHAR (50)   NOT NULL,
    [SourceQuery]                   VARCHAR (1000) NULL,
    [Type]                          VARCHAR (50)   NOT NULL,
    [SourceControlID]               INT            NOT NULL,
    [LastSummaryJobID]              INT            NOT NULL,
    [ExecutionOrder]                INT            NOT NULL,
    [LastExecutionTime]             DATETIME       NULL,
    [CurrentDeliveryJobID]          INT            NULL,
    [LastDeliveryJobID]             INT            NULL,
    [ErrorEmailSent]                DATETIME       NULL,
    [MaxExpectedExecutionDuration]  TIME (0)       NULL,
    [MaxExpectedExecutionEmailSent] DATETIME       NULL,
    CONSTRAINT [PK_SummaryControl] PRIMARY KEY CLUSTERED ([SummaryControlID] ASC)
);


GO
PRINT N'Creating [dbo].[ExtractControl]...';


GO
CREATE TABLE [dbo].[ExtractControl] (
    [ExtractControlID]              INT            IDENTITY (1, 1) NOT NULL,
    [ExtractPackageName]            VARCHAR (50)   NOT NULL,
    [ExtractPackagePath]            VARCHAR (200)  NOT NULL,
    [ProcessType]                   VARCHAR (50)   NULL,
    [SourceControlID]               INT            NULL,
    [DestinationControlID]          INT            NULL,
    [SuiteID]                       INT            NULL,
    [CompanySuiteID]                INT            NULL,
    [ScheduleID]                    INT            NULL,
    [NextRunDateTime]               DATETIME       NULL,
    [SourceQuery]                   VARCHAR (MAX)  NULL,
    [SourceQueryMapping]            VARCHAR (MAX)  NULL,
    [TruncateExtractTable]          BIT            NULL,
    [ExtractTable]                  VARCHAR (50)   NULL,
    [ExecutionOrder]                INT            NOT NULL,
    [ExecutionOrderGroup]           INT            NOT NULL,
    [ConnectionCheckQuery]          VARCHAR (1000) NULL,
    [ConnectionCheckResult]         INT            NULL,
    [CheckConnection]               BIT            NULL,
    [DataCurrencyCheckQuery]        VARCHAR (1000) NULL,
    [DataCurrencyCheckResult]       INT            NULL,
    [CheckDataCurrency]             BIT            NULL,
    [RunAs32bit]                    BIT            NULL,
    [ExtractStartTime]              DATETIME       NOT NULL,
    [Status]                        VARCHAR (1)    NULL,
    [StatusChangeDateTime]          DATETIME       NULL,
    [LastExtractJobID]              INT            NOT NULL,
    [CheckExtractRowCount]          BIT            NULL,
    [FailedCount]                   INT            NULL,
    [FailedCountEmailSent]          DATETIME       NULL,
    [MaxExpectedExecutionDuration]  TIME (0)       NULL,
    [MaxExpectedExecutionEmailSent] DATETIME       NULL,
    CONSTRAINT [PK_ExtractControl] PRIMARY KEY CLUSTERED ([ExtractControlID] ASC),
    CONSTRAINT [IX_ExtractControl] UNIQUE NONCLUSTERED ([ExtractPackageName] ASC, [SuiteID] ASC, [ExecutionOrderGroup] ASC, [SourceControlID] ASC)
);


GO
PRINT N'Creating [dbo].[SourceType]...';


GO
CREATE TABLE [dbo].[SourceType] (
    [SourceTypeID]   INT           IDENTITY (1, 1) NOT NULL,
    [SourceTypeName] VARCHAR (100) NULL,
    CONSTRAINT [PK_SourceType] PRIMARY KEY CLUSTERED ([SourceTypeID] ASC)
);


GO
PRINT N'Creating [dbo].[Schedule]...';


GO
CREATE TABLE [dbo].[Schedule] (
    [ScheduleID]     INT           IDENTITY (1, 1) NOT NULL,
    [ScheduleName]   VARCHAR (100) NOT NULL,
    [ScheduleTypeID] INT           NOT NULL,
    [StartTime]      TIME (0)      NULL,
    [EndTime]        TIME (0)      NULL,
    [OccursEvery]    TIME (0)      NULL,
    [Mon]            BIT           NULL,
    [Tue]            BIT           NULL,
    [Wed]            BIT           NULL,
    [Thu]            BIT           NULL,
    [Fri]            BIT           NULL,
    [Sat]            BIT           NULL,
    [Sun]            BIT           NULL,
    CONSTRAINT [PK_Schedule] PRIMARY KEY CLUSTERED ([ScheduleID] ASC),
    CONSTRAINT [uc_ScheduleScheduleName] UNIQUE NONCLUSTERED ([ScheduleName] ASC)
);


GO
PRINT N'Creating [dbo].[DeliveryExecutionLog]...';


GO
CREATE TABLE [dbo].[DeliveryExecutionLog] (
    [DeliveryExecutionLog]       INT              IDENTITY (1, 1) NOT NULL,
    [DeliveryControlID]          INT              NOT NULL,
    [DeliveryJobID]              INT              NOT NULL,
    [ExtractJobID]               INT              NOT NULL,
    [StartTime]                  DATETIME         NOT NULL,
    [EndTime]                    DATETIME         NOT NULL,
    [ManagerGUID]                UNIQUEIDENTIFIER NULL,
    [SuccessFlag]                INT              NOT NULL,
    [CompletedFlag]              INT              NOT NULL,
    [MessageSource]              VARCHAR (1000)   NULL,
    [Message]                    VARCHAR (1000)   NULL,
    [RowsDelivered]              INT              NULL,
    [RowsErrored]                INT              NULL,
    [DeliveryPackageName]        VARCHAR (100)    NULL,
    [DeliveryPackagePath]        VARCHAR (100)    NULL,
    [DeliveryPackagePathAndName] VARCHAR (250)    NULL,
    [ScheduleType]               VARCHAR (50)     NULL,
    [ExecutionOrder]             INT              NULL,
    [LastExecutionTime]          DATETIME         NULL,
    [NextLastExecutionTime]      DATETIME         NOT NULL,
    CONSTRAINT [PK_DeliveryExecutionLog_1] PRIMARY KEY CLUSTERED ([DeliveryExecutionLog] ASC)
);


GO
PRINT N'Creating [dbo].[ScheduleOutageWindow]...';


GO
CREATE TABLE [dbo].[ScheduleOutageWindow] (
    [ScheduleOutageWindowID] INT           IDENTITY (1, 1) NOT NULL,
    [StartDateTime]          DATETIME      NOT NULL,
    [EndDateTime]            DATETIME      NOT NULL,
    [ReasonForOutage]        VARCHAR (400) NULL,
    CONSTRAINT [PK_ScheduleOutageWindow] PRIMARY KEY CLUSTERED ([ScheduleOutageWindowID] ASC)
);


GO
PRINT N'Creating [dbo].[SourceControl]...';


GO
CREATE TABLE [dbo].[SourceControl] (
    [SourceControlID]       INT          IDENTITY (1, 1) NOT NULL,
    [SourceName]            VARCHAR (50) NULL,
    [SourceTypeID]          INT          NULL,
    [AccessWindowStartMins] INT          NULL,
    [AccessWindowEndMins]   INT          NULL,
    [SSISConfigurationID]   INT          NULL,
    CONSTRAINT [PK_SourceControl] PRIMARY KEY CLUSTERED ([SourceControlID] ASC)
);


GO
PRINT N'Creating [dbo].[ETLParameters]...';


GO
CREATE TABLE [dbo].[ETLParameters] (
    [ETLParameterName]  VARCHAR (50) NOT NULL,
    [ETLParameterValue] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_ETLParameters] PRIMARY KEY CLUSTERED ([ETLParameterName] ASC)
);


GO
PRINT N'Creating [dbo].[SummaryExecutionLog]...';


GO
CREATE TABLE [dbo].[SummaryExecutionLog] (
    [SummaryExecutionLogID] INT              IDENTITY (1, 1) NOT NULL,
    [SummaryControlID]      INT              NULL,
    [SummaryJobID]          INT              NULL,
    [DeliveryJobID]         INT              NULL,
    [SummaryPackageName]    VARCHAR (100)    NULL,
    [SummaryTableName]      VARCHAR (100)    NULL,
    [StartTime]             DATETIME         NULL,
    [EndTime]               DATETIME         NULL,
    [ManagerGUID]           UNIQUEIDENTIFIER NULL,
    [SuccessFlag]           INT              NULL,
    [CompletedFlag]         INT              NULL,
    [MessageSource]         VARCHAR (MAX)    NULL,
    [Message]               VARCHAR (MAX)    NULL,
    [ScheduleType]          VARCHAR (50)     NULL,
    [ExecutionOrder]        INT              NULL,
    [SourceControlID]       INT              NULL,
    [SourceControlValue]    VARCHAR (255)    NULL,
    [Type]                  VARCHAR (50)     NULL,
    [RowsSummarized]        INT              NULL,
    CONSTRAINT [PK_SummaryExecutionLog] PRIMARY KEY CLUSTERED ([SummaryExecutionLogID] ASC)
);


GO
PRINT N'Creating [dbo].[Suite]...';


GO
CREATE TABLE [dbo].[Suite] (
    [SuiteID]                       INT          IDENTITY (1, 1) NOT NULL,
    [SuiteName]                     VARCHAR (50) NULL,
    [Status]                        CHAR (1)     NULL,
    [StatusChangeDateTime]          DATETIME     NULL,
    [MaxExpectedExecutionDuration]  TIME (0)     NULL,
    [MaxExpectedExecutionEmailSent] DATETIME     NULL,
    CONSTRAINT [PK_Suite] PRIMARY KEY CLUSTERED ([SuiteID] ASC)
);


GO
PRINT N'Creating [dbo].[DeliveryControl]...';


GO
CREATE TABLE [dbo].[DeliveryControl] (
    [DeliveryControlID]             INT           IDENTITY (1, 1) NOT NULL,
    [DeliveryPackageName]           VARCHAR (100) NOT NULL,
    [DeliveryPackagePath]           VARCHAR (100) NULL,
    [ProcessType]                   VARCHAR (100) NULL,
    [DeliveryTable]                 VARCHAR (100) NULL,
    [SourceControlID]               INT           NULL,
    [ExtractTable]                  VARCHAR (100) NULL,
    [ErrorTable]                    VARCHAR (100) NULL,
    [ScheduleType]                  VARCHAR (100) NULL,
    [SourceIdentifier]              VARCHAR (100) NULL,
    [BusinessKeyFieldList]          VARCHAR (500) NULL,
    [ExecutionOrder]                INT           NOT NULL,
    [LastExecutionTime]             DATETIME      NOT NULL,
    [LastDeliveryJobID]             INT           NOT NULL,
    [LastExtractJobID]              INT           NULL,
    [CurrentExtractJobID]           INT           NULL,
    [ErrorRaised]                   DATETIME      NULL,
    [ErrorEmailSent]                DATETIME      NULL,
    [MaxExpectedExecutionDuration]  TIME (0)      NULL,
    [MaxExpectedExecutionEmailSent] DATETIME      NULL,
    [InsertOnly]                    BIT           NULL,
    CONSTRAINT [PK_DeliveryControl] PRIMARY KEY CLUSTERED ([DeliveryControlID] ASC)
);


GO
PRINT N'Creating [dbo].[SSISConfiguration]...';


GO
CREATE TABLE [dbo].[SSISConfiguration] (
    [SSISConfigurationID] INT            IDENTITY (1, 1) NOT NULL,
    [ConfigurationFilter] NVARCHAR (255) NOT NULL,
    [ConfiguredValue]     NVARCHAR (500) NULL,
    [PackagePath]         NVARCHAR (255) NOT NULL,
    [ConfiguredValueType] NVARCHAR (20)  NOT NULL,
    [Description]         NVARCHAR (255) NULL,
    CONSTRAINT [PK_SSISConfigurationID] PRIMARY KEY CLUSTERED ([SSISConfigurationID] ASC),
    CONSTRAINT [IX_SSISConfiguration_ConfiguratonFilter] UNIQUE NONCLUSTERED ([ConfigurationFilter] ASC)
);


GO
PRINT N'Creating [dbo].[ExtractExecutionLog]...';


GO
CREATE TABLE [dbo].[ExtractExecutionLog] (
    [ExtractExecutionLogID]     INT              IDENTITY (1, 1) NOT NULL,
    [ExtractJobID]              INT              NULL,
    [StartTime]                 DATETIME         NULL,
    [EndTime]                   DATETIME         NULL,
    [ManagerGUID]               UNIQUEIDENTIFIER NULL,
    [SuccessFlag]               INT              NULL,
    [CompletedFlag]             INT              NULL,
    [MessageSource]             VARCHAR (1000)   NULL,
    [Message]                   VARCHAR (MAX)    NULL,
    [RowsExtracted]             INT              NULL,
    [ExtractControlID]          INT              NULL,
    [ExtractPackagePathAndName] VARCHAR (100)    NULL,
    [ExtractPackageName]        VARCHAR (50)     NULL,
    [ExtractPackagePath]        VARCHAR (50)     NULL,
    [SourceControlID]           INT              NULL,
    [SourceControlValue]        VARCHAR (255)    NULL,
    [DestinationControlID]      INT              NULL,
    [DestinationControlValue]   VARCHAR (255)    NULL,
    [SuiteID]                   INT              NULL,
    [SuiteName]                 VARCHAR (50)     NULL,
    [ExecutionOrder]            INT              NULL,
    [ExtractStartTime]          DATETIME         NULL,
    [ExtractEndTime]            DATETIME         NULL,
    [NextExtractStartTime]      DATETIME         NULL,
    CONSTRAINT [PK_ExtractExecutionLog] PRIMARY KEY NONCLUSTERED ([ExtractExecutionLogID] ASC)
);


GO
PRINT N'Creating [dbo].[ExtractExecutionLog].[IX_ExtractExecutionLog]...';


GO
CREATE CLUSTERED INDEX [IX_ExtractExecutionLog]
    ON [dbo].[ExtractExecutionLog]([ExtractJobID] ASC, [ExtractPackageName] ASC, [SuiteName] ASC);


GO
PRINT N'Creating [dbo].[QlikviewPermissions]...';


GO
CREATE TABLE [dbo].[QlikviewPermissions] (
    [PermissionType]        VARCHAR (50)  NOT NULL,
    [AccountName]           VARCHAR (255) NOT NULL,
    [Permission]            VARCHAR (255) NOT NULL,
    [PermissionDescription] VARCHAR (255) NULL,
    [LastChangeDateTime]    DATETIME      NULL,
    [LastChangedBy]         VARCHAR (255) NULL,
    CONSTRAINT [PK_QlikviewPermissions] PRIMARY KEY CLUSTERED ([PermissionType] ASC, [AccountName] ASC, [Permission] ASC)
);


GO
PRINT N'Creating [dbo].[StagingControl]...';


GO
CREATE TABLE [dbo].[StagingControl] (
    [StagingControlID]                INT           IDENTITY (1, 1) NOT NULL,
    [StagingPackagePath]              VARCHAR (200) NULL,
    [StagingPackageName]              VARCHAR (50)  NOT NULL,
    [ProcessType]                     VARCHAR (100) NULL,
    [SuiteID]                         INT           NULL,
    [ScheduleID]                      INT           NULL,
    [NextRunDateTime]                 DATETIME      NULL,
    [SourceControlID]                 INT           NOT NULL,
    [RemoteSourceControlID]           INT           NULL,
    [DelimiterChar]                   CHAR (1)      NULL,
    [StagingDestControlID]            INT           NULL,
    [TruncateStagingTable]            BIT           NULL,
    [StagingTable]                    VARCHAR (100) NULL,
    [SourceQuery]                     VARCHAR (MAX) NULL,
    [SourceQueryMapping]              VARCHAR (MAX) NULL,
    [MergeQuery]                      VARCHAR (MAX) NULL,
    [HasHeader]                       BIT           NULL,
    [HasFooter]                       BIT           NULL,
    [CheckExtractRowCount]            BIT           NULL,
    [RunAs32Bit]                      BIT           NULL,
    [Status]                          VARCHAR (1)   NULL,
    [StatusChangeDateTime]            DATETIME      NULL,
    [FailedCount]                     INT           NULL,
    [FailedCountEmailSent]            DATETIME      NULL,
    [MaxExpectedExecutionDuration]    TIME (0)      NULL,
    [MaxExpectedExecutionEmailSent]   DATETIME      NULL,
    [MaxExpectedDurationBetweenFiles] TIME (0)      NULL,
    [LastStagingJobID]                INT           NULL,
    [LastExecutionTime]               DATETIME      NULL,
    [LastProcessedTime]               DATETIME      NULL,
    CONSTRAINT [PK_StagingControl] PRIMARY KEY CLUSTERED ([StagingControlID] ASC)
);


GO
PRINT N'Creating [dbo].[StagingExecutionLog]...';


GO
CREATE TABLE [dbo].[StagingExecutionLog] (
    [StagingExecutionLogID]     INT              IDENTITY (1, 1) NOT NULL,
    [StagingControlID]          INT              NULL,
    [StagingJobID]              INT              NULL,
    [StartTime]                 DATETIME         NULL,
    [EndTime]                   DATETIME         NULL,
    [ManagerGUID]               UNIQUEIDENTIFIER NULL,
    [SuccessFlag]               INT              NULL,
    [CompletedFlag]             INT              NULL,
    [MessageSource]             VARCHAR (1000)   NULL,
    [Message]                   VARCHAR (MAX)    NULL,
    [RowsStaged]                INT              NULL,
    [RowsInserted]              INT              NULL,
    [RowsDeleted]               INT              NULL,
    [RowsUpdated]               INT              NULL,
    [StagingPackagePathAndName] VARCHAR (250)    NULL,
    [StagingPackageName]        VARCHAR (50)     NULL,
    [StagingPackagePath]        VARCHAR (200)    NULL,
    [ActualFileName]            VARCHAR (200)    NULL,
    [SourceControlID]           INT              NULL,
    [SourceControlValue]        VARCHAR (255)    NULL,
    [ProcessingControlID]       INT              NULL,
    [ProcessingControlValue]    VARCHAR (255)    NULL,
    [StagingDestControlID]      INT              NULL,
    [StagingDestControlValue]   VARCHAR (255)    NULL,
    [SuiteID]                   INT              NULL,
    [SuiteName]                 VARCHAR (50)     NULL,
    [RunAs32Bit]                BIT              NULL,
    [ExtractStartTime]          DATETIME         NULL,
    [ExtractEndTime]            DATETIME         NULL,
    CONSTRAINT [PK_FileExecutionLog] PRIMARY KEY CLUSTERED ([StagingExecutionLogID] ASC)
);


GO
PRINT N'Creating [Audit].[Audit_DDL_Events]...';


GO
CREATE TABLE [Audit].[Audit_DDL_Events] (
    [DDL_Event_Time]    DATETIME       NULL,
    [DDL_Login_Name]    NVARCHAR (150) NULL,
    [DDL_User_Name]     NVARCHAR (150) NULL,
    [DDL_Server_Name]   NVARCHAR (150) NULL,
    [DDL_Database_Name] NVARCHAR (150) NULL,
    [DDL_Schema_Name]   NVARCHAR (150) NULL,
    [DDL_Object_Name]   NVARCHAR (150) NULL,
    [DDL_Object_Type]   NVARCHAR (150) NULL,
    [DDL_Command]       NVARCHAR (MAX) NULL,
    [DDL_CreateCommand] NVARCHAR (MAX) NULL
);


GO
PRINT N'Creating [Audit].[AuditData]...';


GO
CREATE TABLE [Audit].[AuditData] (
    [AuditDataID]     INT            IDENTITY (1, 1) NOT NULL,
    [Type]            CHAR (1)       NULL,
    [TableName]       VARCHAR (128)  NULL,
    [PrimaryKeyField] VARCHAR (1000) NULL,
    [PrimaryKeyValue] VARCHAR (1000) NULL,
    [FieldName]       VARCHAR (128)  NULL,
    [OldValue]        NVARCHAR (MAX) NULL,
    [NewValue]        NVARCHAR (MAX) NULL,
    [UpdateDate]      DATETIME       NULL,
    [UserName]        VARCHAR (128)  NULL
);


GO
PRINT N'Creating [Audit].[AuditMonitorTableColumns]...';


GO
CREATE TABLE [Audit].[AuditMonitorTableColumns] (
    [AuditMonitorTableColumnsID] INT            IDENTITY (1, 1) NOT NULL,
    [SchemaName]                 NVARCHAR (250) NULL,
    [TableName]                  NVARCHAR (250) NULL,
    [ColumnName]                 NVARCHAR (250) NULL,
    CONSTRAINT [PK_AuditMonitorTableColumns] PRIMARY KEY CLUSTERED ([AuditMonitorTableColumnsID] ASC)
);


GO
PRINT N'Creating [dbo].[SSISConfigurationSource]...';


GO
CREATE SYNONYM [dbo].[SSISConfigurationSource] FOR [DWReferenceConfiguration].[dbo].[SSISConfiguration];


GO
PRINT N'Creating DF_SummaryControl_Suite...';


GO
ALTER TABLE [dbo].[SummaryControl]
    ADD CONSTRAINT [DF_SummaryControl_Suite] DEFAULT ('Daily') FOR [ScheduleType];


GO
PRINT N'Creating DF_SummaryControl_ExecutionOrder...';


GO
ALTER TABLE [dbo].[SummaryControl]
    ADD CONSTRAINT [DF_SummaryControl_ExecutionOrder] DEFAULT ((1)) FOR [ExecutionOrder];


GO
PRINT N'Creating DF_ExtractControl_RunAs32bit...';


GO
ALTER TABLE [dbo].[ExtractControl]
    ADD CONSTRAINT [DF_ExtractControl_RunAs32bit] DEFAULT ((1)) FOR [RunAs32bit];


GO
PRINT N'Creating DF_ExtractControl_ExtractStartTime...';


GO
ALTER TABLE [dbo].[ExtractControl]
    ADD CONSTRAINT [DF_ExtractControl_ExtractStartTime] DEFAULT ('1900-01-01 00:00:00') FOR [ExtractStartTime];


GO
PRINT N'Creating DF_ExtractControl_LastExtractJobID...';


GO
ALTER TABLE [dbo].[ExtractControl]
    ADD CONSTRAINT [DF_ExtractControl_LastExtractJobID] DEFAULT ((0)) FOR [LastExtractJobID];


GO
PRINT N'Creating DF_DeliveryControl_LastExecutionTime1...';


GO
ALTER TABLE [dbo].[DeliveryControl]
    ADD CONSTRAINT [DF_DeliveryControl_LastExecutionTime1] DEFAULT ('1900-01-01 00:00:00') FOR [LastExecutionTime];


GO
PRINT N'Creating DF_DeliveryControl_LastDeliveryJobID1...';


GO
ALTER TABLE [dbo].[DeliveryControl]
    ADD CONSTRAINT [DF_DeliveryControl_LastDeliveryJobID1] DEFAULT ((0)) FOR [LastDeliveryJobID];


GO
PRINT N'Creating DF__AuditData__Updat__4BCC3ABA...';


GO
ALTER TABLE [Audit].[AuditData]
    ADD CONSTRAINT [DF__AuditData__Updat__4BCC3ABA] DEFAULT (getdate()) FOR [UpdateDate];


GO
PRINT N'Creating FK_ExtractControl_Schedule...';


GO
ALTER TABLE [dbo].[ExtractControl]
    ADD CONSTRAINT [FK_ExtractControl_Schedule] FOREIGN KEY ([ScheduleID]) REFERENCES [dbo].[Schedule] ([ScheduleID]);


GO
PRINT N'Creating FK_ExtractControl_SourceControl...';


GO
ALTER TABLE [dbo].[ExtractControl]
    ADD CONSTRAINT [FK_ExtractControl_SourceControl] FOREIGN KEY ([SourceControlID]) REFERENCES [dbo].[SourceControl] ([SourceControlID]);


GO
PRINT N'Creating FK_ExtractControl_SourceControl1...';


GO
ALTER TABLE [dbo].[ExtractControl]
    ADD CONSTRAINT [FK_ExtractControl_SourceControl1] FOREIGN KEY ([DestinationControlID]) REFERENCES [dbo].[SourceControl] ([SourceControlID]);


GO
PRINT N'Creating FK_ExtractControl_Suite...';


GO
ALTER TABLE [dbo].[ExtractControl]
    ADD CONSTRAINT [FK_ExtractControl_Suite] FOREIGN KEY ([SuiteID]) REFERENCES [dbo].[Suite] ([SuiteID]);


GO
PRINT N'Creating FK_Schedule_ScheduleType...';


GO
ALTER TABLE [dbo].[Schedule]
    ADD CONSTRAINT [FK_Schedule_ScheduleType] FOREIGN KEY ([ScheduleTypeID]) REFERENCES [dbo].[ScheduleType] ([ScheduleTypeID]);


GO
PRINT N'Creating FK_SourceControl_SourceType...';


GO
ALTER TABLE [dbo].[SourceControl]
    ADD CONSTRAINT [FK_SourceControl_SourceType] FOREIGN KEY ([SourceTypeID]) REFERENCES [dbo].[SourceType] ([SourceTypeID]);


GO
PRINT N'Creating FK_SourceControl_SSISConfiguration...';


GO
ALTER TABLE [dbo].[SourceControl]
    ADD CONSTRAINT [FK_SourceControl_SSISConfiguration] FOREIGN KEY ([SSISConfigurationID]) REFERENCES [dbo].[SSISConfiguration] ([SSISConfigurationID]);


GO
PRINT N'Creating FK_StagingControl_SourceControl...';


GO
ALTER TABLE [dbo].[StagingControl]
    ADD CONSTRAINT [FK_StagingControl_SourceControl] FOREIGN KEY ([RemoteSourceControlID]) REFERENCES [dbo].[SourceControl] ([SourceControlID]);


GO
PRINT N'Creating FK_StagingControl_SourceControl1...';


GO
ALTER TABLE [dbo].[StagingControl]
    ADD CONSTRAINT [FK_StagingControl_SourceControl1] FOREIGN KEY ([StagingDestControlID]) REFERENCES [dbo].[SourceControl] ([SourceControlID]);


GO
PRINT N'Creating FK_StagingControl_Suite...';


GO
ALTER TABLE [dbo].[StagingControl]
    ADD CONSTRAINT [FK_StagingControl_Suite] FOREIGN KEY ([SuiteID]) REFERENCES [dbo].[Suite] ([SuiteID]);


GO
PRINT N'Creating [dbo].[ScheduleType_ChangeTracking]...';


GO

CREATE TRIGGER [dbo].[ScheduleType_ChangeTracking] on [dbo].[ScheduleType] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[dbo].[ScheduleType]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'ScheduleTypeID'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleTypeID,d.ScheduleTypeID)), 'ScheduleTypeID', CONVERT(NVARCHAR(MAX), d.ScheduleTypeID), CONVERT(NVARCHAR(MAX),i.ScheduleTypeID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleTypeID = d.ScheduleTypeID
WHERE i.ScheduleTypeID <> d.ScheduleTypeID OR i.ScheduleTypeID IS NULL AND d.ScheduleTypeID IS NOT NULL OR i.ScheduleTypeID IS NOT NULL AND d.ScheduleTypeID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleTypeID,d.ScheduleTypeID)), 'ScheduleTypeName', CONVERT(NVARCHAR(MAX), d.ScheduleTypeName), CONVERT(NVARCHAR(MAX),i.ScheduleTypeName),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleTypeID = d.ScheduleTypeID
WHERE i.ScheduleTypeName <> d.ScheduleTypeName OR i.ScheduleTypeName IS NULL AND d.ScheduleTypeName IS NOT NULL OR i.ScheduleTypeName IS NOT NULL AND d.ScheduleTypeName IS NULL
GO
PRINT N'Creating [dbo].[SummaryControl_ChangeTracking]...';


GO

CREATE TRIGGER [dbo].[SummaryControl_ChangeTracking] on [dbo].[SummaryControl] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[dbo].[SummaryControl]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'SummaryControlID'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SummaryControlID,d.SummaryControlID)), 'SummaryControlID', CONVERT(NVARCHAR(MAX), d.SummaryControlID), CONVERT(NVARCHAR(MAX),i.SummaryControlID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SummaryControlID = d.SummaryControlID
WHERE i.SummaryControlID <> d.SummaryControlID OR i.SummaryControlID IS NULL AND d.SummaryControlID IS NOT NULL OR i.SummaryControlID IS NOT NULL AND d.SummaryControlID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SummaryControlID,d.SummaryControlID)), 'SummaryPackageName', CONVERT(NVARCHAR(MAX), d.SummaryPackageName), CONVERT(NVARCHAR(MAX),i.SummaryPackageName),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SummaryControlID = d.SummaryControlID
WHERE i.SummaryPackageName <> d.SummaryPackageName OR i.SummaryPackageName IS NULL AND d.SummaryPackageName IS NOT NULL OR i.SummaryPackageName IS NOT NULL AND d.SummaryPackageName IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SummaryControlID,d.SummaryControlID)), 'SummaryPackagePath', CONVERT(NVARCHAR(MAX), d.SummaryPackagePath), CONVERT(NVARCHAR(MAX),i.SummaryPackagePath),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SummaryControlID = d.SummaryControlID
WHERE i.SummaryPackagePath <> d.SummaryPackagePath OR i.SummaryPackagePath IS NULL AND d.SummaryPackagePath IS NOT NULL OR i.SummaryPackagePath IS NOT NULL AND d.SummaryPackagePath IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SummaryControlID,d.SummaryControlID)), 'SummaryTableName', CONVERT(NVARCHAR(MAX), d.SummaryTableName), CONVERT(NVARCHAR(MAX),i.SummaryTableName),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SummaryControlID = d.SummaryControlID
WHERE i.SummaryTableName <> d.SummaryTableName OR i.SummaryTableName IS NULL AND d.SummaryTableName IS NOT NULL OR i.SummaryTableName IS NOT NULL AND d.SummaryTableName IS NULL
INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SummaryControlID,d.SummaryControlID)), 'ScheduleType', CONVERT(NVARCHAR(MAX), d.ScheduleType), CONVERT(NVARCHAR(MAX),i.ScheduleType),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SummaryControlID = d.SummaryControlID
WHERE i.ScheduleType <> d.ScheduleType OR i.ScheduleType IS NULL AND d.ScheduleType IS NOT NULL OR i.ScheduleType IS NOT NULL AND d.ScheduleType IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SummaryControlID,d.SummaryControlID)), 'SourceQuery', CONVERT(NVARCHAR(MAX), d.SourceQuery), CONVERT(NVARCHAR(MAX),i.SourceQuery),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SummaryControlID = d.SummaryControlID
WHERE i.SourceQuery <> d.SourceQuery OR i.SourceQuery IS NULL AND d.SourceQuery IS NOT NULL OR i.SourceQuery IS NOT NULL AND d.SourceQuery IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SummaryControlID,d.SummaryControlID)), 'Type', CONVERT(NVARCHAR(MAX), d.Type), CONVERT(NVARCHAR(MAX),i.Type),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SummaryControlID = d.SummaryControlID
WHERE i.Type <> d.Type OR i.Type IS NULL AND d.Type IS NOT NULL OR i.Type IS NOT NULL AND d.Type IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SummaryControlID,d.SummaryControlID)), 'SourceControlID', CONVERT(NVARCHAR(MAX), d.SourceControlID), CONVERT(NVARCHAR(MAX),i.SourceControlID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SummaryControlID = d.SummaryControlID
WHERE i.SourceControlID <> d.SourceControlID OR i.SourceControlID IS NULL AND d.SourceControlID IS NOT NULL OR i.SourceControlID IS NOT NULL AND d.SourceControlID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SummaryControlID,d.SummaryControlID)), 'ExecutionOrder', CONVERT(NVARCHAR(MAX), d.ExecutionOrder), CONVERT(NVARCHAR(MAX),i.ExecutionOrder),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SummaryControlID = d.SummaryControlID
WHERE i.ExecutionOrder <> d.ExecutionOrder OR i.ExecutionOrder IS NULL AND d.ExecutionOrder IS NOT NULL OR i.ExecutionOrder IS NOT NULL AND d.ExecutionOrder IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SummaryControlID,d.SummaryControlID)), 'MaxExpectedExecutionDuration', CONVERT(NVARCHAR(MAX), d.MaxExpectedExecutionDuration), CONVERT(NVARCHAR(MAX),i.MaxExpectedExecutionDuration),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SummaryControlID = d.SummaryControlID
WHERE i.MaxExpectedExecutionDuration <> d.MaxExpectedExecutionDuration OR i.MaxExpectedExecutionDuration IS NULL AND d.MaxExpectedExecutionDuration IS NOT NULL OR i.MaxExpectedExecutionDuration IS NOT NULL AND d.MaxExpectedExecutionDuration IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SummaryControlID,d.SummaryControlID)), 'MaxExpectedExecutionEmailSent', CONVERT(NVARCHAR(MAX), d.MaxExpectedExecutionEmailSent), CONVERT(NVARCHAR(MAX),i.MaxExpectedExecutionEmailSent),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SummaryControlID = d.SummaryControlID
WHERE i.MaxExpectedExecutionEmailSent <> d.MaxExpectedExecutionEmailSent OR i.MaxExpectedExecutionEmailSent IS NULL AND d.MaxExpectedExecutionEmailSent IS NOT NULL OR i.MaxExpectedExecutionEmailSent IS NOT NULL AND d.MaxExpectedExecutionEmailSent IS NULL
GO
PRINT N'Creating [dbo].[ExtractControl_ChangeTracking]...';


GO

CREATE TRIGGER [dbo].[ExtractControl_ChangeTracking] on [dbo].[ExtractControl] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[dbo].[ExtractControl]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'ExtractControlID'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'ExtractControlID', CONVERT(NVARCHAR(MAX), d.ExtractControlID), CONVERT(NVARCHAR(MAX),i.ExtractControlID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.ExtractControlID <> d.ExtractControlID OR i.ExtractControlID IS NULL AND d.ExtractControlID IS NOT NULL OR i.ExtractControlID IS NOT NULL AND d.ExtractControlID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'ExtractPackageName', CONVERT(NVARCHAR(MAX), d.ExtractPackageName), CONVERT(NVARCHAR(MAX),i.ExtractPackageName),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.ExtractPackageName <> d.ExtractPackageName OR i.ExtractPackageName IS NULL AND d.ExtractPackageName IS NOT NULL OR i.ExtractPackageName IS NOT NULL AND d.ExtractPackageName IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'ExtractPackagePath', CONVERT(NVARCHAR(MAX), d.ExtractPackagePath), CONVERT(NVARCHAR(MAX),i.ExtractPackagePath),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.ExtractPackagePath <> d.ExtractPackagePath OR i.ExtractPackagePath IS NULL AND d.ExtractPackagePath IS NOT NULL OR i.ExtractPackagePath IS NOT NULL AND d.ExtractPackagePath IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'ProcessType', CONVERT(NVARCHAR(MAX), d.ProcessType), CONVERT(NVARCHAR(MAX),i.ProcessType),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.ProcessType <> d.ProcessType OR i.ProcessType IS NULL AND d.ProcessType IS NOT NULL OR i.ProcessType IS NOT NULL AND d.ProcessType IS NULL
INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'SourceControlID', CONVERT(NVARCHAR(MAX), d.SourceControlID), CONVERT(NVARCHAR(MAX),i.SourceControlID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.SourceControlID <> d.SourceControlID OR i.SourceControlID IS NULL AND d.SourceControlID IS NOT NULL OR i.SourceControlID IS NOT NULL AND d.SourceControlID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'DestinationControlID', CONVERT(NVARCHAR(MAX), d.DestinationControlID), CONVERT(NVARCHAR(MAX),i.DestinationControlID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.DestinationControlID <> d.DestinationControlID OR i.DestinationControlID IS NULL AND d.DestinationControlID IS NOT NULL OR i.DestinationControlID IS NOT NULL AND d.DestinationControlID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'SuiteID', CONVERT(NVARCHAR(MAX), d.SuiteID), CONVERT(NVARCHAR(MAX),i.SuiteID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.SuiteID <> d.SuiteID OR i.SuiteID IS NULL AND d.SuiteID IS NOT NULL OR i.SuiteID IS NOT NULL AND d.SuiteID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'CompanySuiteID', CONVERT(NVARCHAR(MAX), d.CompanySuiteID), CONVERT(NVARCHAR(MAX),i.CompanySuiteID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.CompanySuiteID <> d.CompanySuiteID OR i.CompanySuiteID IS NULL AND d.CompanySuiteID IS NOT NULL OR i.CompanySuiteID IS NOT NULL AND d.CompanySuiteID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'ScheduleID', CONVERT(NVARCHAR(MAX), d.ScheduleID), CONVERT(NVARCHAR(MAX),i.ScheduleID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.ScheduleID <> d.ScheduleID OR i.ScheduleID IS NULL AND d.ScheduleID IS NOT NULL OR i.ScheduleID IS NOT NULL AND d.ScheduleID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'SourceQuery', CONVERT(NVARCHAR(MAX), d.SourceQuery), CONVERT(NVARCHAR(MAX),i.SourceQuery),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.SourceQuery <> d.SourceQuery OR i.SourceQuery IS NULL AND d.SourceQuery IS NOT NULL OR i.SourceQuery IS NOT NULL AND d.SourceQuery IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'SourceQueryMapping', CONVERT(NVARCHAR(MAX), d.SourceQueryMapping), CONVERT(NVARCHAR(MAX),i.SourceQueryMapping),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.SourceQueryMapping <> d.SourceQueryMapping OR i.SourceQueryMapping IS NULL AND d.SourceQueryMapping IS NOT NULL OR i.SourceQueryMapping IS NOT NULL AND d.SourceQueryMapping IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'TruncateExtractTable', CONVERT(NVARCHAR(MAX), d.TruncateExtractTable), CONVERT(NVARCHAR(MAX),i.TruncateExtractTable),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.TruncateExtractTable <> d.TruncateExtractTable OR i.TruncateExtractTable IS NULL AND d.TruncateExtractTable IS NOT NULL OR i.TruncateExtractTable IS NOT NULL AND d.TruncateExtractTable IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'ExtractTable', CONVERT(NVARCHAR(MAX), d.ExtractTable), CONVERT(NVARCHAR(MAX),i.ExtractTable),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.ExtractTable <> d.ExtractTable OR i.ExtractTable IS NULL AND d.ExtractTable IS NOT NULL OR i.ExtractTable IS NOT NULL AND d.ExtractTable IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'ExecutionOrder', CONVERT(NVARCHAR(MAX), d.ExecutionOrder), CONVERT(NVARCHAR(MAX),i.ExecutionOrder),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.ExecutionOrder <> d.ExecutionOrder OR i.ExecutionOrder IS NULL AND d.ExecutionOrder IS NOT NULL OR i.ExecutionOrder IS NOT NULL AND d.ExecutionOrder IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'ExecutionOrderGroup', CONVERT(NVARCHAR(MAX), d.ExecutionOrderGroup), CONVERT(NVARCHAR(MAX),i.ExecutionOrderGroup),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.ExecutionOrderGroup <> d.ExecutionOrderGroup OR i.ExecutionOrderGroup IS NULL AND d.ExecutionOrderGroup IS NOT NULL OR i.ExecutionOrderGroup IS NOT NULL AND d.ExecutionOrderGroup IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'ConnectionCheckQuery', CONVERT(NVARCHAR(MAX), d.ConnectionCheckQuery), CONVERT(NVARCHAR(MAX),i.ConnectionCheckQuery),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.ConnectionCheckQuery <> d.ConnectionCheckQuery OR i.ConnectionCheckQuery IS NULL AND d.ConnectionCheckQuery IS NOT NULL OR i.ConnectionCheckQuery IS NOT NULL AND d.ConnectionCheckQuery IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'ConnectionCheckResult', CONVERT(NVARCHAR(MAX), d.ConnectionCheckResult), CONVERT(NVARCHAR(MAX),i.ConnectionCheckResult),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.ConnectionCheckResult <> d.ConnectionCheckResult OR i.ConnectionCheckResult IS NULL AND d.ConnectionCheckResult IS NOT NULL OR i.ConnectionCheckResult IS NOT NULL AND d.ConnectionCheckResult IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'CheckConnection', CONVERT(NVARCHAR(MAX), d.CheckConnection), CONVERT(NVARCHAR(MAX),i.CheckConnection),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.CheckConnection <> d.CheckConnection OR i.CheckConnection IS NULL AND d.CheckConnection IS NOT NULL OR i.CheckConnection IS NOT NULL AND d.CheckConnection IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'DataCurrencyCheckQuery', CONVERT(NVARCHAR(MAX), d.DataCurrencyCheckQuery), CONVERT(NVARCHAR(MAX),i.DataCurrencyCheckQuery),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.DataCurrencyCheckQuery <> d.DataCurrencyCheckQuery OR i.DataCurrencyCheckQuery IS NULL AND d.DataCurrencyCheckQuery IS NOT NULL OR i.DataCurrencyCheckQuery IS NOT NULL AND d.DataCurrencyCheckQuery IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'DataCurrencyCheckResult', CONVERT(NVARCHAR(MAX), d.DataCurrencyCheckResult), CONVERT(NVARCHAR(MAX),i.DataCurrencyCheckResult),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.DataCurrencyCheckResult <> d.DataCurrencyCheckResult OR i.DataCurrencyCheckResult IS NULL AND d.DataCurrencyCheckResult IS NOT NULL OR i.DataCurrencyCheckResult IS NOT NULL AND d.DataCurrencyCheckResult IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'CheckDataCurrency', CONVERT(NVARCHAR(MAX), d.CheckDataCurrency), CONVERT(NVARCHAR(MAX),i.CheckDataCurrency),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.CheckDataCurrency <> d.CheckDataCurrency OR i.CheckDataCurrency IS NULL AND d.CheckDataCurrency IS NOT NULL OR i.CheckDataCurrency IS NOT NULL AND d.CheckDataCurrency IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'RunAs32bit', CONVERT(NVARCHAR(MAX), d.RunAs32bit), CONVERT(NVARCHAR(MAX),i.RunAs32bit),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.RunAs32bit <> d.RunAs32bit OR i.RunAs32bit IS NULL AND d.RunAs32bit IS NOT NULL OR i.RunAs32bit IS NOT NULL AND d.RunAs32bit IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ExtractControlID,d.ExtractControlID)), 'CheckExtractRowCount', CONVERT(NVARCHAR(MAX), d.CheckExtractRowCount), CONVERT(NVARCHAR(MAX),i.CheckExtractRowCount),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ExtractControlID = d.ExtractControlID
WHERE i.CheckExtractRowCount <> d.CheckExtractRowCount OR i.CheckExtractRowCount IS NULL AND d.CheckExtractRowCount IS NOT NULL OR i.CheckExtractRowCount IS NOT NULL AND d.CheckExtractRowCount IS NULL
GO
PRINT N'Creating [dbo].[SourceType_ChangeTracking]...';


GO

CREATE TRIGGER [dbo].[SourceType_ChangeTracking] on [dbo].[SourceType] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[dbo].[SourceType]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'SourceTypeID'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SourceTypeID,d.SourceTypeID)), 'SourceTypeID', CONVERT(NVARCHAR(MAX), d.SourceTypeID), CONVERT(NVARCHAR(MAX),i.SourceTypeID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SourceTypeID = d.SourceTypeID
WHERE i.SourceTypeID <> d.SourceTypeID OR i.SourceTypeID IS NULL AND d.SourceTypeID IS NOT NULL OR i.SourceTypeID IS NOT NULL AND d.SourceTypeID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SourceTypeID,d.SourceTypeID)), 'SourceTypeName', CONVERT(NVARCHAR(MAX), d.SourceTypeName), CONVERT(NVARCHAR(MAX),i.SourceTypeName),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SourceTypeID = d.SourceTypeID
WHERE i.SourceTypeName <> d.SourceTypeName OR i.SourceTypeName IS NULL AND d.SourceTypeName IS NOT NULL OR i.SourceTypeName IS NOT NULL AND d.SourceTypeName IS NULL
GO
PRINT N'Creating [dbo].[Schedule_ChangeTracking]...';


GO

CREATE TRIGGER [dbo].[Schedule_ChangeTracking] on [dbo].[Schedule] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[dbo].[Schedule]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'ScheduleID'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'ScheduleID', CONVERT(NVARCHAR(MAX), d.ScheduleID), CONVERT(NVARCHAR(MAX),i.ScheduleID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.ScheduleID <> d.ScheduleID OR i.ScheduleID IS NULL AND d.ScheduleID IS NOT NULL OR i.ScheduleID IS NOT NULL AND d.ScheduleID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'ScheduleName', CONVERT(NVARCHAR(MAX), d.ScheduleName), CONVERT(NVARCHAR(MAX),i.ScheduleName),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.ScheduleName <> d.ScheduleName OR i.ScheduleName IS NULL AND d.ScheduleName IS NOT NULL OR i.ScheduleName IS NOT NULL AND d.ScheduleName IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'ScheduleTypeID', CONVERT(NVARCHAR(MAX), d.ScheduleTypeID), CONVERT(NVARCHAR(MAX),i.ScheduleTypeID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.ScheduleTypeID <> d.ScheduleTypeID OR i.ScheduleTypeID IS NULL AND d.ScheduleTypeID IS NOT NULL OR i.ScheduleTypeID IS NOT NULL AND d.ScheduleTypeID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'StartTime', CONVERT(NVARCHAR(MAX), d.StartTime), CONVERT(NVARCHAR(MAX),i.StartTime),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.StartTime <> d.StartTime OR i.StartTime IS NULL AND d.StartTime IS NOT NULL OR i.StartTime IS NOT NULL AND d.StartTime IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'EndTime', CONVERT(NVARCHAR(MAX), d.EndTime), CONVERT(NVARCHAR(MAX),i.EndTime),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.EndTime <> d.EndTime OR i.EndTime IS NULL AND d.EndTime IS NOT NULL OR i.EndTime IS NOT NULL AND d.EndTime IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'OccursEvery', CONVERT(NVARCHAR(MAX), d.OccursEvery), CONVERT(NVARCHAR(MAX),i.OccursEvery),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.OccursEvery <> d.OccursEvery OR i.OccursEvery IS NULL AND d.OccursEvery IS NOT NULL OR i.OccursEvery IS NOT NULL AND d.OccursEvery IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'Mon', CONVERT(NVARCHAR(MAX), d.Mon), CONVERT(NVARCHAR(MAX),i.Mon),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.Mon <> d.Mon OR i.Mon IS NULL AND d.Mon IS NOT NULL OR i.Mon IS NOT NULL AND d.Mon IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'Tue', CONVERT(NVARCHAR(MAX), d.Tue), CONVERT(NVARCHAR(MAX),i.Tue),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.Tue <> d.Tue OR i.Tue IS NULL AND d.Tue IS NOT NULL OR i.Tue IS NOT NULL AND d.Tue IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'Wed', CONVERT(NVARCHAR(MAX), d.Wed), CONVERT(NVARCHAR(MAX),i.Wed),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.Wed <> d.Wed OR i.Wed IS NULL AND d.Wed IS NOT NULL OR i.Wed IS NOT NULL AND d.Wed IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'Thu', CONVERT(NVARCHAR(MAX), d.Thu), CONVERT(NVARCHAR(MAX),i.Thu),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.Thu <> d.Thu OR i.Thu IS NULL AND d.Thu IS NOT NULL OR i.Thu IS NOT NULL AND d.Thu IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'Fri', CONVERT(NVARCHAR(MAX), d.Fri), CONVERT(NVARCHAR(MAX),i.Fri),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.Fri <> d.Fri OR i.Fri IS NULL AND d.Fri IS NOT NULL OR i.Fri IS NOT NULL AND d.Fri IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'Sat', CONVERT(NVARCHAR(MAX), d.Sat), CONVERT(NVARCHAR(MAX),i.Sat),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.Sat <> d.Sat OR i.Sat IS NULL AND d.Sat IS NOT NULL OR i.Sat IS NOT NULL AND d.Sat IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleID,d.ScheduleID)), 'Sun', CONVERT(NVARCHAR(MAX), d.Sun), CONVERT(NVARCHAR(MAX),i.Sun),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleID = d.ScheduleID
WHERE i.Sun <> d.Sun OR i.Sun IS NULL AND d.Sun IS NOT NULL OR i.Sun IS NOT NULL AND d.Sun IS NULL
GO
PRINT N'Creating [dbo].[ScheduleOutageWindow_ChangeTracking]...';


GO

CREATE TRIGGER [dbo].[ScheduleOutageWindow_ChangeTracking] on [dbo].[ScheduleOutageWindow] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[dbo].[ScheduleOutageWindow]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'ScheduleOutageWindowID'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleOutageWindowID,d.ScheduleOutageWindowID)), 'ScheduleOutageWindowID', CONVERT(NVARCHAR(MAX), d.ScheduleOutageWindowID), CONVERT(NVARCHAR(MAX),i.ScheduleOutageWindowID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleOutageWindowID = d.ScheduleOutageWindowID
WHERE i.ScheduleOutageWindowID <> d.ScheduleOutageWindowID OR i.ScheduleOutageWindowID IS NULL AND d.ScheduleOutageWindowID IS NOT NULL OR i.ScheduleOutageWindowID IS NOT NULL AND d.ScheduleOutageWindowID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleOutageWindowID,d.ScheduleOutageWindowID)), 'StartDateTime', CONVERT(NVARCHAR(MAX), d.StartDateTime), CONVERT(NVARCHAR(MAX),i.StartDateTime),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleOutageWindowID = d.ScheduleOutageWindowID
WHERE i.StartDateTime <> d.StartDateTime OR i.StartDateTime IS NULL AND d.StartDateTime IS NOT NULL OR i.StartDateTime IS NOT NULL AND d.StartDateTime IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleOutageWindowID,d.ScheduleOutageWindowID)), 'EndDateTime', CONVERT(NVARCHAR(MAX), d.EndDateTime), CONVERT(NVARCHAR(MAX),i.EndDateTime),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleOutageWindowID = d.ScheduleOutageWindowID
WHERE i.EndDateTime <> d.EndDateTime OR i.EndDateTime IS NULL AND d.EndDateTime IS NOT NULL OR i.EndDateTime IS NOT NULL AND d.EndDateTime IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.ScheduleOutageWindowID,d.ScheduleOutageWindowID)), 'ReasonForOutage', CONVERT(NVARCHAR(MAX), d.ReasonForOutage), CONVERT(NVARCHAR(MAX),i.ReasonForOutage),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.ScheduleOutageWindowID = d.ScheduleOutageWindowID
WHERE i.ReasonForOutage <> d.ReasonForOutage OR i.ReasonForOutage IS NULL AND d.ReasonForOutage IS NOT NULL OR i.ReasonForOutage IS NOT NULL AND d.ReasonForOutage IS NULL
GO
PRINT N'Creating [dbo].[SourceControl_ChangeTracking]...';


GO

CREATE TRIGGER [dbo].[SourceControl_ChangeTracking] on [dbo].[SourceControl] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[dbo].[SourceControl]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'SourceControlID'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SourceControlID,d.SourceControlID)), 'SourceControlID', CONVERT(NVARCHAR(MAX), d.SourceControlID), CONVERT(NVARCHAR(MAX),i.SourceControlID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SourceControlID = d.SourceControlID
WHERE i.SourceControlID <> d.SourceControlID OR i.SourceControlID IS NULL AND d.SourceControlID IS NOT NULL OR i.SourceControlID IS NOT NULL AND d.SourceControlID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SourceControlID,d.SourceControlID)), 'SourceName', CONVERT(NVARCHAR(MAX), d.SourceName), CONVERT(NVARCHAR(MAX),i.SourceName),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SourceControlID = d.SourceControlID
WHERE i.SourceName <> d.SourceName OR i.SourceName IS NULL AND d.SourceName IS NOT NULL OR i.SourceName IS NOT NULL AND d.SourceName IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SourceControlID,d.SourceControlID)), 'SourceTypeID', CONVERT(NVARCHAR(MAX), d.SourceTypeID), CONVERT(NVARCHAR(MAX),i.SourceTypeID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SourceControlID = d.SourceControlID
WHERE i.SourceTypeID <> d.SourceTypeID OR i.SourceTypeID IS NULL AND d.SourceTypeID IS NOT NULL OR i.SourceTypeID IS NOT NULL AND d.SourceTypeID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SourceControlID,d.SourceControlID)), 'AccessWindowStartMins', CONVERT(NVARCHAR(MAX), d.AccessWindowStartMins), CONVERT(NVARCHAR(MAX),i.AccessWindowStartMins),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SourceControlID = d.SourceControlID
WHERE i.AccessWindowStartMins <> d.AccessWindowStartMins OR i.AccessWindowStartMins IS NULL AND d.AccessWindowStartMins IS NOT NULL OR i.AccessWindowStartMins IS NOT NULL AND d.AccessWindowStartMins IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SourceControlID,d.SourceControlID)), 'AccessWindowEndMins', CONVERT(NVARCHAR(MAX), d.AccessWindowEndMins), CONVERT(NVARCHAR(MAX),i.AccessWindowEndMins),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SourceControlID = d.SourceControlID
WHERE i.AccessWindowEndMins <> d.AccessWindowEndMins OR i.AccessWindowEndMins IS NULL AND d.AccessWindowEndMins IS NOT NULL OR i.AccessWindowEndMins IS NOT NULL AND d.AccessWindowEndMins IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SourceControlID,d.SourceControlID)), 'SSISConfigurationID', CONVERT(NVARCHAR(MAX), d.SSISConfigurationID), CONVERT(NVARCHAR(MAX),i.SSISConfigurationID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SourceControlID = d.SourceControlID
WHERE i.SSISConfigurationID <> d.SSISConfigurationID OR i.SSISConfigurationID IS NULL AND d.SSISConfigurationID IS NOT NULL OR i.SSISConfigurationID IS NOT NULL AND d.SSISConfigurationID IS NULL
GO
PRINT N'Creating [dbo].[Suite_ChangeTracking]...';


GO

CREATE TRIGGER [dbo].[Suite_ChangeTracking] on [dbo].[Suite] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[dbo].[Suite]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'SuiteID'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SuiteID,d.SuiteID)), 'SuiteID', CONVERT(NVARCHAR(MAX), d.SuiteID), CONVERT(NVARCHAR(MAX),i.SuiteID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SuiteID = d.SuiteID
WHERE i.SuiteID <> d.SuiteID OR i.SuiteID IS NULL AND d.SuiteID IS NOT NULL OR i.SuiteID IS NOT NULL AND d.SuiteID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SuiteID,d.SuiteID)), 'SuiteName', CONVERT(NVARCHAR(MAX), d.SuiteName), CONVERT(NVARCHAR(MAX),i.SuiteName),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SuiteID = d.SuiteID
WHERE i.SuiteName <> d.SuiteName OR i.SuiteName IS NULL AND d.SuiteName IS NOT NULL OR i.SuiteName IS NOT NULL AND d.SuiteName IS NULL
GO
PRINT N'Creating [dbo].[DeliveryControl_ChangeTracking]...';


GO

CREATE TRIGGER [dbo].[DeliveryControl_ChangeTracking] on [dbo].[DeliveryControl] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[dbo].[DeliveryControl]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'DeliveryControlID'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'DeliveryControlID', CONVERT(NVARCHAR(MAX), d.DeliveryControlID), CONVERT(NVARCHAR(MAX),i.DeliveryControlID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.DeliveryControlID <> d.DeliveryControlID OR i.DeliveryControlID IS NULL AND d.DeliveryControlID IS NOT NULL OR i.DeliveryControlID IS NOT NULL AND d.DeliveryControlID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'DeliveryPackageName', CONVERT(NVARCHAR(MAX), d.DeliveryPackageName), CONVERT(NVARCHAR(MAX),i.DeliveryPackageName),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.DeliveryPackageName <> d.DeliveryPackageName OR i.DeliveryPackageName IS NULL AND d.DeliveryPackageName IS NOT NULL OR i.DeliveryPackageName IS NOT NULL AND d.DeliveryPackageName IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'DeliveryPackagePath', CONVERT(NVARCHAR(MAX), d.DeliveryPackagePath), CONVERT(NVARCHAR(MAX),i.DeliveryPackagePath),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.DeliveryPackagePath <> d.DeliveryPackagePath OR i.DeliveryPackagePath IS NULL AND d.DeliveryPackagePath IS NOT NULL OR i.DeliveryPackagePath IS NOT NULL AND d.DeliveryPackagePath IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'ProcessType', CONVERT(NVARCHAR(MAX), d.ProcessType), CONVERT(NVARCHAR(MAX),i.ProcessType),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.ProcessType <> d.ProcessType OR i.ProcessType IS NULL AND d.ProcessType IS NOT NULL OR i.ProcessType IS NOT NULL AND d.ProcessType IS NULL
INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'DeliveryTable', CONVERT(NVARCHAR(MAX), d.DeliveryTable), CONVERT(NVARCHAR(MAX),i.DeliveryTable),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.DeliveryTable <> d.DeliveryTable OR i.DeliveryTable IS NULL AND d.DeliveryTable IS NOT NULL OR i.DeliveryTable IS NOT NULL AND d.DeliveryTable IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'SourceControlID', CONVERT(NVARCHAR(MAX), d.SourceControlID), CONVERT(NVARCHAR(MAX),i.SourceControlID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.SourceControlID <> d.SourceControlID OR i.SourceControlID IS NULL AND d.SourceControlID IS NOT NULL OR i.SourceControlID IS NOT NULL AND d.SourceControlID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'ExtractTable', CONVERT(NVARCHAR(MAX), d.ExtractTable), CONVERT(NVARCHAR(MAX),i.ExtractTable),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.ExtractTable <> d.ExtractTable OR i.ExtractTable IS NULL AND d.ExtractTable IS NOT NULL OR i.ExtractTable IS NOT NULL AND d.ExtractTable IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'ErrorTable', CONVERT(NVARCHAR(MAX), d.ErrorTable), CONVERT(NVARCHAR(MAX),i.ErrorTable),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.ErrorTable <> d.ErrorTable OR i.ErrorTable IS NULL AND d.ErrorTable IS NOT NULL OR i.ErrorTable IS NOT NULL AND d.ErrorTable IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'ScheduleType', CONVERT(NVARCHAR(MAX), d.ScheduleType), CONVERT(NVARCHAR(MAX),i.ScheduleType),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.ScheduleType <> d.ScheduleType OR i.ScheduleType IS NULL AND d.ScheduleType IS NOT NULL OR i.ScheduleType IS NOT NULL AND d.ScheduleType IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'SourceIdentifier', CONVERT(NVARCHAR(MAX), d.SourceIdentifier), CONVERT(NVARCHAR(MAX),i.SourceIdentifier),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.SourceIdentifier <> d.SourceIdentifier OR i.SourceIdentifier IS NULL AND d.SourceIdentifier IS NOT NULL OR i.SourceIdentifier IS NOT NULL AND d.SourceIdentifier IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'BusinessKeyFieldList', CONVERT(NVARCHAR(MAX), d.BusinessKeyFieldList), CONVERT(NVARCHAR(MAX),i.BusinessKeyFieldList),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.BusinessKeyFieldList <> d.BusinessKeyFieldList OR i.BusinessKeyFieldList IS NULL AND d.BusinessKeyFieldList IS NOT NULL OR i.BusinessKeyFieldList IS NOT NULL AND d.BusinessKeyFieldList IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'ExecutionOrder', CONVERT(NVARCHAR(MAX), d.ExecutionOrder), CONVERT(NVARCHAR(MAX),i.ExecutionOrder),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.ExecutionOrder <> d.ExecutionOrder OR i.ExecutionOrder IS NULL AND d.ExecutionOrder IS NOT NULL OR i.ExecutionOrder IS NOT NULL AND d.ExecutionOrder IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'MaxExpectedExecutionDuration', CONVERT(NVARCHAR(MAX), d.MaxExpectedExecutionDuration), CONVERT(NVARCHAR(MAX),i.MaxExpectedExecutionDuration),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.MaxExpectedExecutionDuration <> d.MaxExpectedExecutionDuration OR i.MaxExpectedExecutionDuration IS NULL AND d.MaxExpectedExecutionDuration IS NOT NULL OR i.MaxExpectedExecutionDuration IS NOT NULL AND d.MaxExpectedExecutionDuration IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.DeliveryControlID,d.DeliveryControlID)), 'InsertOnly', CONVERT(NVARCHAR(MAX), d.InsertOnly), CONVERT(NVARCHAR(MAX),i.InsertOnly),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.DeliveryControlID = d.DeliveryControlID
WHERE i.InsertOnly <> d.InsertOnly OR i.InsertOnly IS NULL AND d.InsertOnly IS NOT NULL OR i.InsertOnly IS NOT NULL AND d.InsertOnly IS NULL
GO
PRINT N'Creating [dbo].[SSISConfiguration_ChangeTracking]...';


GO

CREATE TRIGGER [dbo].[SSISConfiguration_ChangeTracking] on [dbo].[SSISConfiguration] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[dbo].[SSISConfiguration]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'SSISConfigurationID'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SSISConfigurationID,d.SSISConfigurationID)), 'SSISConfigurationID', CONVERT(NVARCHAR(MAX), d.SSISConfigurationID), CONVERT(NVARCHAR(MAX),i.SSISConfigurationID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SSISConfigurationID = d.SSISConfigurationID
WHERE i.SSISConfigurationID <> d.SSISConfigurationID OR i.SSISConfigurationID IS NULL AND d.SSISConfigurationID IS NOT NULL OR i.SSISConfigurationID IS NOT NULL AND d.SSISConfigurationID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SSISConfigurationID,d.SSISConfigurationID)), 'ConfigurationFilter', CONVERT(NVARCHAR(MAX), d.ConfigurationFilter), CONVERT(NVARCHAR(MAX),i.ConfigurationFilter),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SSISConfigurationID = d.SSISConfigurationID
WHERE i.ConfigurationFilter <> d.ConfigurationFilter OR i.ConfigurationFilter IS NULL AND d.ConfigurationFilter IS NOT NULL OR i.ConfigurationFilter IS NOT NULL AND d.ConfigurationFilter IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SSISConfigurationID,d.SSISConfigurationID)), 'ConfiguredValue', CONVERT(NVARCHAR(MAX), d.ConfiguredValue), CONVERT(NVARCHAR(MAX),i.ConfiguredValue),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SSISConfigurationID = d.SSISConfigurationID
WHERE i.ConfiguredValue <> d.ConfiguredValue OR i.ConfiguredValue IS NULL AND d.ConfiguredValue IS NOT NULL OR i.ConfiguredValue IS NOT NULL AND d.ConfiguredValue IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SSISConfigurationID,d.SSISConfigurationID)), 'PackagePath', CONVERT(NVARCHAR(MAX), d.PackagePath), CONVERT(NVARCHAR(MAX),i.PackagePath),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SSISConfigurationID = d.SSISConfigurationID
WHERE i.PackagePath <> d.PackagePath OR i.PackagePath IS NULL AND d.PackagePath IS NOT NULL OR i.PackagePath IS NOT NULL AND d.PackagePath IS NULL
INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SSISConfigurationID,d.SSISConfigurationID)), 'ConfiguredValueType', CONVERT(NVARCHAR(MAX), d.ConfiguredValueType), CONVERT(NVARCHAR(MAX),i.ConfiguredValueType),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SSISConfigurationID = d.SSISConfigurationID
WHERE i.ConfiguredValueType <> d.ConfiguredValueType OR i.ConfiguredValueType IS NULL AND d.ConfiguredValueType IS NOT NULL OR i.ConfiguredValueType IS NOT NULL AND d.ConfiguredValueType IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.SSISConfigurationID,d.SSISConfigurationID)), 'Description', CONVERT(NVARCHAR(MAX), d.Description), CONVERT(NVARCHAR(MAX),i.Description),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.SSISConfigurationID = d.SSISConfigurationID
WHERE i.Description <> d.Description OR i.Description IS NULL AND d.Description IS NOT NULL OR i.Description IS NOT NULL AND d.Description IS NULL
GO
PRINT N'Creating [dbo].[QlikviewPermissionsChangeTrigger]...';


GO


CREATE TRIGGER [dbo].QlikviewPermissionsChangeTrigger 
ON [dbo].QlikviewPermissions
AFTER INSERT, UPDATE AS
	UPDATE QlikviewPermissions
	SET [LastChangeDateTime] = GETDATE()
		,[LastChangedBy] = System_User
	WHERE exists (select * 
				from inserted
				where QlikviewPermissions.PermissionType = inserted.PermissionType 
				and QlikviewPermissions.AccountName = inserted.AccountName 
				and QlikviewPermissions.Permission = inserted.Permission)
GO
PRINT N'Creating [dbo].[QlikviewPermissions_ChangeTracking]...';


GO

CREATE TRIGGER [dbo].[QlikviewPermissions_ChangeTracking] on [dbo].[QlikviewPermissions] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[dbo].[QlikviewPermissions]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'AccountName + Permission + PermissionType'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.AccountName,d.AccountName)) + ',' + convert(varchar(100), coalesce(i.Permission,d.Permission)) + ',' + convert(varchar(100), coalesce(i.PermissionType,d.PermissionType)), 'PermissionType', CONVERT(NVARCHAR(MAX), d.PermissionType), CONVERT(NVARCHAR(MAX),i.PermissionType),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.AccountName = d.AccountName and i.Permission = d.Permission and i.PermissionType = d.PermissionType
WHERE i.PermissionType <> d.PermissionType OR i.PermissionType IS NULL AND d.PermissionType IS NOT NULL OR i.PermissionType IS NOT NULL AND d.PermissionType IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.AccountName,d.AccountName)) + ',' + convert(varchar(100), coalesce(i.Permission,d.Permission)) + ',' + convert(varchar(100), coalesce(i.PermissionType,d.PermissionType)), 'AccountName', CONVERT(NVARCHAR(MAX), d.AccountName), CONVERT(NVARCHAR(MAX),i.AccountName),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.AccountName = d.AccountName and i.Permission = d.Permission and i.PermissionType = d.PermissionType
WHERE i.AccountName <> d.AccountName OR i.AccountName IS NULL AND d.AccountName IS NOT NULL OR i.AccountName IS NOT NULL AND d.AccountName IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.AccountName,d.AccountName)) + ',' + convert(varchar(100), coalesce(i.Permission,d.Permission)) + ',' + convert(varchar(100), coalesce(i.PermissionType,d.PermissionType)), 'Permission', CONVERT(NVARCHAR(MAX), d.Permission), CONVERT(NVARCHAR(MAX),i.Permission),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.AccountName = d.AccountName and i.Permission = d.Permission and i.PermissionType = d.PermissionType
WHERE i.Permission <> d.Permission OR i.Permission IS NULL AND d.Permission IS NOT NULL OR i.Permission IS NOT NULL AND d.Permission IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.AccountName,d.AccountName)) + ',' + convert(varchar(100), coalesce(i.Permission,d.Permission)) + ',' + convert(varchar(100), coalesce(i.PermissionType,d.PermissionType)), 'PermissionDescription', CONVERT(NVARCHAR(MAX), d.PermissionDescription), CONVERT(NVARCHAR(MAX),i.PermissionDescription),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.AccountName = d.AccountName and i.Permission = d.Permission and i.PermissionType = d.PermissionType
WHERE i.PermissionDescription <> d.PermissionDescription OR i.PermissionDescription IS NULL AND d.PermissionDescription IS NOT NULL OR i.PermissionDescription IS NOT NULL AND d.PermissionDescription IS NULL
GO
PRINT N'Creating [dbo].[StagingControl_ChangeTracking]...';


GO

CREATE TRIGGER [dbo].[StagingControl_ChangeTracking] on [dbo].[StagingControl] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[dbo].[StagingControl]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'StagingControlID'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'StagingControlID', CONVERT(NVARCHAR(MAX), d.StagingControlID), CONVERT(NVARCHAR(MAX),i.StagingControlID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.StagingControlID <> d.StagingControlID OR i.StagingControlID IS NULL AND d.StagingControlID IS NOT NULL OR i.StagingControlID IS NOT NULL AND d.StagingControlID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'StagingPackagePath', CONVERT(NVARCHAR(MAX), d.StagingPackagePath), CONVERT(NVARCHAR(MAX),i.StagingPackagePath),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.StagingPackagePath <> d.StagingPackagePath OR i.StagingPackagePath IS NULL AND d.StagingPackagePath IS NOT NULL OR i.StagingPackagePath IS NOT NULL AND d.StagingPackagePath IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'StagingPackageName', CONVERT(NVARCHAR(MAX), d.StagingPackageName), CONVERT(NVARCHAR(MAX),i.StagingPackageName),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.StagingPackageName <> d.StagingPackageName OR i.StagingPackageName IS NULL AND d.StagingPackageName IS NOT NULL OR i.StagingPackageName IS NOT NULL AND d.StagingPackageName IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'ProcessType', CONVERT(NVARCHAR(MAX), d.ProcessType), CONVERT(NVARCHAR(MAX),i.ProcessType),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.ProcessType <> d.ProcessType OR i.ProcessType IS NULL AND d.ProcessType IS NOT NULL OR i.ProcessType IS NOT NULL AND d.ProcessType IS NULL
INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'SuiteID', CONVERT(NVARCHAR(MAX), d.SuiteID), CONVERT(NVARCHAR(MAX),i.SuiteID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.SuiteID <> d.SuiteID OR i.SuiteID IS NULL AND d.SuiteID IS NOT NULL OR i.SuiteID IS NOT NULL AND d.SuiteID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'ScheduleID', CONVERT(NVARCHAR(MAX), d.ScheduleID), CONVERT(NVARCHAR(MAX),i.ScheduleID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.ScheduleID <> d.ScheduleID OR i.ScheduleID IS NULL AND d.ScheduleID IS NOT NULL OR i.ScheduleID IS NOT NULL AND d.ScheduleID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'SourceControlID', CONVERT(NVARCHAR(MAX), d.SourceControlID), CONVERT(NVARCHAR(MAX),i.SourceControlID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.SourceControlID <> d.SourceControlID OR i.SourceControlID IS NULL AND d.SourceControlID IS NOT NULL OR i.SourceControlID IS NOT NULL AND d.SourceControlID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'RemoteSourceControlID', CONVERT(NVARCHAR(MAX), d.RemoteSourceControlID), CONVERT(NVARCHAR(MAX),i.RemoteSourceControlID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.RemoteSourceControlID <> d.RemoteSourceControlID OR i.RemoteSourceControlID IS NULL AND d.RemoteSourceControlID IS NOT NULL OR i.RemoteSourceControlID IS NOT NULL AND d.RemoteSourceControlID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'DelimiterChar', CONVERT(NVARCHAR(MAX), d.DelimiterChar), CONVERT(NVARCHAR(MAX),i.DelimiterChar),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.DelimiterChar <> d.DelimiterChar OR i.DelimiterChar IS NULL AND d.DelimiterChar IS NOT NULL OR i.DelimiterChar IS NOT NULL AND d.DelimiterChar IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'StagingDestControlID', CONVERT(NVARCHAR(MAX), d.StagingDestControlID), CONVERT(NVARCHAR(MAX),i.StagingDestControlID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.StagingDestControlID <> d.StagingDestControlID OR i.StagingDestControlID IS NULL AND d.StagingDestControlID IS NOT NULL OR i.StagingDestControlID IS NOT NULL AND d.StagingDestControlID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'StagingTable', CONVERT(NVARCHAR(MAX), d.StagingTable), CONVERT(NVARCHAR(MAX),i.StagingTable),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.StagingTable <> d.StagingTable OR i.StagingTable IS NULL AND d.StagingTable IS NOT NULL OR i.StagingTable IS NOT NULL AND d.StagingTable IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'SourceQuery', CONVERT(NVARCHAR(MAX), d.SourceQuery), CONVERT(NVARCHAR(MAX),i.SourceQuery),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.SourceQuery <> d.SourceQuery OR i.SourceQuery IS NULL AND d.SourceQuery IS NOT NULL OR i.SourceQuery IS NOT NULL AND d.SourceQuery IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'SourceQueryMapping', CONVERT(NVARCHAR(MAX), d.SourceQueryMapping), CONVERT(NVARCHAR(MAX),i.SourceQueryMapping),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.SourceQueryMapping <> d.SourceQueryMapping OR i.SourceQueryMapping IS NULL AND d.SourceQueryMapping IS NOT NULL OR i.SourceQueryMapping IS NOT NULL AND d.SourceQueryMapping IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'MergeQuery', CONVERT(NVARCHAR(MAX), d.MergeQuery), CONVERT(NVARCHAR(MAX),i.MergeQuery),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.MergeQuery <> d.MergeQuery OR i.MergeQuery IS NULL AND d.MergeQuery IS NOT NULL OR i.MergeQuery IS NOT NULL AND d.MergeQuery IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'HasHeader', CONVERT(NVARCHAR(MAX), d.HasHeader), CONVERT(NVARCHAR(MAX),i.HasHeader),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.HasHeader <> d.HasHeader OR i.HasHeader IS NULL AND d.HasHeader IS NOT NULL OR i.HasHeader IS NOT NULL AND d.HasHeader IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'HasFooter', CONVERT(NVARCHAR(MAX), d.HasFooter), CONVERT(NVARCHAR(MAX),i.HasFooter),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.HasFooter <> d.HasFooter OR i.HasFooter IS NULL AND d.HasFooter IS NOT NULL OR i.HasFooter IS NOT NULL AND d.HasFooter IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'CheckExtractRowCount', CONVERT(NVARCHAR(MAX), d.CheckExtractRowCount), CONVERT(NVARCHAR(MAX),i.CheckExtractRowCount),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.CheckExtractRowCount <> d.CheckExtractRowCount OR i.CheckExtractRowCount IS NULL AND d.CheckExtractRowCount IS NOT NULL OR i.CheckExtractRowCount IS NOT NULL AND d.CheckExtractRowCount IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'RunAs32Bit', CONVERT(NVARCHAR(MAX), d.RunAs32Bit), CONVERT(NVARCHAR(MAX),i.RunAs32Bit),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.RunAs32Bit <> d.RunAs32Bit OR i.RunAs32Bit IS NULL AND d.RunAs32Bit IS NOT NULL OR i.RunAs32Bit IS NOT NULL AND d.RunAs32Bit IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'MaxExpectedExecutionDuration', CONVERT(NVARCHAR(MAX), d.MaxExpectedExecutionDuration), CONVERT(NVARCHAR(MAX),i.MaxExpectedExecutionDuration),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.MaxExpectedExecutionDuration <> d.MaxExpectedExecutionDuration OR i.MaxExpectedExecutionDuration IS NULL AND d.MaxExpectedExecutionDuration IS NOT NULL OR i.MaxExpectedExecutionDuration IS NOT NULL AND d.MaxExpectedExecutionDuration IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'MaxExpectedExecutionEmailSent', CONVERT(NVARCHAR(MAX), d.MaxExpectedExecutionEmailSent), CONVERT(NVARCHAR(MAX),i.MaxExpectedExecutionEmailSent),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.MaxExpectedExecutionEmailSent <> d.MaxExpectedExecutionEmailSent OR i.MaxExpectedExecutionEmailSent IS NULL AND d.MaxExpectedExecutionEmailSent IS NOT NULL OR i.MaxExpectedExecutionEmailSent IS NOT NULL AND d.MaxExpectedExecutionEmailSent IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.StagingControlID,d.StagingControlID)), 'TruncateStagingTable', CONVERT(NVARCHAR(MAX), d.TruncateStagingTable), CONVERT(NVARCHAR(MAX),i.TruncateStagingTable),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.StagingControlID = d.StagingControlID
WHERE i.TruncateStagingTable <> d.TruncateStagingTable OR i.TruncateStagingTable IS NULL AND d.TruncateStagingTable IS NOT NULL OR i.TruncateStagingTable IS NOT NULL AND d.TruncateStagingTable IS NULL
GO
PRINT N'Creating [Audit].[AuditMonitorTableColumns_ChangeTracking]...';


GO

CREATE TRIGGER [Audit].[AuditMonitorTableColumns_ChangeTracking] on [Audit].[AuditMonitorTableColumns] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = '[Audit].[AuditMonitorTableColumns]'
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = 'AuditMonitorTableColumnsID'
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + ' ' + CONVERT(VARCHAR(12), GETDATE(), 114)



-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT  FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT  FROM deleted
		SELECT @Type = 'U'
	END
	ELSE
	BEGIN
		SELECT @Type = 'I'
	END
END
ELSE
BEGIN
	--SELECT  FROM deleted
	SELECT @Type = 'D'
END


INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.AuditMonitorTableColumnsID,d.AuditMonitorTableColumnsID)), 'AuditMonitorTableColumnsID', CONVERT(NVARCHAR(MAX), d.AuditMonitorTableColumnsID), CONVERT(NVARCHAR(MAX),i.AuditMonitorTableColumnsID),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.AuditMonitorTableColumnsID = d.AuditMonitorTableColumnsID
WHERE i.AuditMonitorTableColumnsID <> d.AuditMonitorTableColumnsID OR i.AuditMonitorTableColumnsID IS NULL AND d.AuditMonitorTableColumnsID IS NOT NULL OR i.AuditMonitorTableColumnsID IS NOT NULL AND d.AuditMonitorTableColumnsID IS NULL

INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, convert(varchar(100), coalesce(i.AuditMonitorTableColumnsID,d.AuditMonitorTableColumnsID)), 'TableName', CONVERT(NVARCHAR(MAX), d.TableName), CONVERT(NVARCHAR(MAX),i.TableName),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON  i.AuditMonitorTableColumnsID = d.AuditMonitorTableColumnsID
WHERE i.TableName <> d.TableName OR i.TableName IS NULL AND d.TableName IS NOT NULL OR i.TableName IS NOT NULL AND d.TableName IS NULL
GO
PRINT N'Creating [dbo].[udfPackagePathName]...';


GO
CREATE FUNCTION [dbo].[udfPackagePathName](	@Environment VARCHAR(255), @Path VARCHAR(200), @PackageName VARCHAR(100))
RETURNS VARCHAR(500)
AS
BEGIN
	DECLARE	@PackagePath VARCHAR(500) = ''
	
	IF @Environment IS NOT NULL AND LEN(@Environment) > 0
	BEGIN
		SET @PackagePath = '\' + @Environment
	END
  
    IF @Path IS NOT NULL AND LEN(@Path) > 0
	BEGIN
		SET @PackagePath = @PackagePath + @Path + '\'
	END
	ELSE
    BEGIN
		SET @PackagePath = ''
	END
  
    SET @PackagePath = @PackagePath + @PackageName

	RETURN @PackagePath 
END;
GO
PRINT N'Creating [dbo].[spWritePackageProgressLog]...';


GO
CREATE PROCEDURE [dbo].[spWritePackageProgressLog]
(
    @PackageName         VARCHAR(MAX)
    , @EventType         VARCHAR(MAX)
    , @EventSource         VARCHAR(MAX)
    , @EventCode         VARCHAR(MAX)
    , @EventMessage     VARCHAR(MAX)
    , @JobID           INT
)
AS
BEGIN
	IF LEFT( @EventSource , 12 ) = 'Log Process.'
	BEGIN
		RETURN 0
	END
INSERT INTO dbo.PackageProgressLog(
    PackageName
    , EventType
    , EventSource
    , EventCode 
    , EventMessage
    , EventDate
    , JobID
)
VALUES ( SUBSTRING(@PackageName,1,50), SUBSTRING(@EventType,1,50), SUBSTRING(@EventSource,1,50), SUBSTRING(@EventCode,1,50), @EventMessage, GETDATE(),@JobID );
END
GO
PRINT N'Creating [dbo].[spGetDeliveryManagerPackages]...';


GO
-------------------------------------------------------------------------------
-- Author:	oszymczak
-- Create date: 2013/08/19
-- Description:	Return packages that will be executed based on ScheduleType 
--              and ExecutionOrder
-------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[spGetDeliveryManagerPackages]
	@ScheduleType VARCHAR(100),
	@ExecutionOrder INT
AS
BEGIN
SET NOCOUNT ON;

SELECT DeliveryControlID
FROM DeliveryControl
WHERE ScheduleType = @ScheduleType
AND ExecutionOrder = @ExecutionOrder
AND ISNULL(LastExtractJobID, -1) <> ISNULL(CurrentExtractJobID, -1)
END
GO
PRINT N'Creating [dbo].[spSendEmailProcessHanging]...';


GO



-- =============================================
-- Author:		Dylan Harvey
-- Create date: 21/12/2012
-- Description:	Send an email if process is hanging
--				send on every 24 hours and one on a daily schedule
-- =============================================
 CREATE PROCEDURE [dbo].[spSendEmailProcessHanging] 
	-- Add the parameters for the stored procedure here
	@EmailReceipent varchar(max) = 0,
	@ScheduleType AS VARCHAR (50)

AS
BEGIN

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
   
	DECLARE @Message AS VARCHAR(MAX)
	DECLARE @LogQuery AS VARCHAR(MAX)
	DECLARE @BodyMessage AS VARCHAR(MAX)
	DECLARE @Importance AS VARCHAR(20)
	DECLARE @count INT
	DECLARE @ProfileName NVARCHAR(255)
    DECLARE @tableHTML  NVARCHAR(MAX) 
    DECLARE @Email_Subject NVARCHAR(255)
	DECLARE @SystemName NVARCHAR(255)
    
    -- Set variables
	SELECT @ProfileName =  ConfiguredValue 	FROM SSISConfiguration 	WHERE ConfigurationFilter = 'EmailProfileName'
	SELECT @SystemName = ConfiguredValue FROM SSISConfiguration 	WHERE ConfigurationFilter = 'SystemName'
	SELECT @Email_Subject = '!!!Failure!!! - ' + @SystemName + ' Process hanging'
	SELECT @Importance = 'High'
    
    
	IF @ScheduleType = 'Daily'    
	-- Only run once per day, do not check if an email has been sent
	BEGIN 
		-- Check if processes are taking longer than alocated time
		SELECT @count = COUNT(*) 
		FROM (
		SELECT  SuiteName AS NAME,'Suite' AS [Table]
		FROM Suite
		WHERE Status = 'P'
		AND StatusChangeDateTime + CAST(MaxExpectedExecutionDuration AS datetime) < GETDATE()
		UNION ALL
		SELECT ExtractPackageName AS NAME, 'ExtractControl' AS [Table]
		FROM ExtractControl 
		WHERE Status = 'P'
		AND StatusChangeDateTime + CAST(MaxExpectedExecutionDuration AS datetime) < GETDATE()
		)a
			
			IF @count > 0
			BEGIN
			
				-- Send email if a process is reporting to be hanging
					SET @tableHTML =
					N'<H1>'+@SystemName+' Process Hanging Report</H4>' +
					N'<font size = "3">Hi,<br>'+ CHAR(10) + CHAR(10) +
					N'<br>Please check DWReference, the status is reporting that the tables below with the associated packages'+ 
					' have been running longer that the allocated time. '+
					'The package might have finished and not have had the status updated.<br> This will need to be investigated.'+ CHAR(10) + CHAR(10) +
					N'<br>Please do not reply this email as it is auto generated from ' + @SystemName + 
					' system. If you have any questions with this email please contact ' + @SystemName + ' team.</font>'+
					N'<table border="1">' +
					N'<tr><th>Package Name</th>'+    
					N'<th>Table Name</th>' +
					N'<th>Status Change Date Time</th>'+
					CAST ( ( 
					SELECT td = [NAME], '',
					td = [Table], '',
					td = [StatusChangeDateTime] , ''
					FROM (
							SELECT  SuiteName AS [NAME],'Suite' AS [Table], [StatusChangeDateTime]
							FROM Suite
							WHERE Status = 'P'
							AND StatusChangeDateTime + CAST(MaxExpectedExecutionDuration AS datetime) < GETDATE()
							UNION ALL
							SELECT ExtractPackageName AS [NAME], 'ExtractControl' AS [Table], [StatusChangeDateTime]
							FROM ExtractControl 
							WHERE Status = 'P'
							AND StatusChangeDateTime + CAST(MaxExpectedExecutionDuration AS datetime) < GETDATE()
							)a
							 FOR XML PATH('tr'), TYPE 
					) AS NVARCHAR(MAX) ) +
					N'</table>' ;
					
				EXEC msdb.dbo.sp_send_dbmail @recipients='dylan.harvey@brightstarcorp.com',
					@subject = @Email_Subject,
					@body = @tableHTML,
					@profile_name = @ProfileName,
					@body_format = 'HTML', 
					@Importance = @Importance;
			END
				
	END
	-- Run every hour, only send emails where one has not been sent by the hourly process
	ELSE IF	@ScheduleType = 'Hourly'	
	BEGIN
			-- Check if processes are taking longer than alocated time
			SELECT @count = COUNT(*) 
			FROM (
			SELECT  SuiteName AS NAME,'Suite' AS [Table]
			FROM Suite
			WHERE Status = 'P'
			AND StatusChangeDateTime + CAST(MaxExpectedExecutionDuration AS datetime) < GETDATE()
			AND MaxExpectedExecutionEmailSent IS NULL
			UNION ALL
			SELECT ExtractPackageName AS NAME, 'ExtractControl' AS [Table]
			FROM ExtractControl 
			WHERE Status = 'P'
			AND StatusChangeDateTime + CAST(MaxExpectedExecutionDuration AS datetime) < GETDATE()
			AND MaxExpectedExecutionEmailSent IS NULL
			)a			
				IF @count > 0
				BEGIN			
					-- Send email if a process is reporting to be hanging
						SET @tableHTML =
						N'<H1>'+@SystemName+' Process Hanging Report</H4>' +
						N'<font size = "3">Hi,<br>'+ CHAR(10) + CHAR(10) +
						N'<br>Please check DWReference, the status is reporting that the tables below with the associated packages'+ 
						' have been running longer that the allocated time. '+
						'The package might have finished and not have had the status updated.<br> This will need to be investigated.'+ CHAR(10) + CHAR(10) +
						N'<br>Please do not reply this email as it is auto generated from ' + @SystemName + 
						' system. If you have any questions with this email please contact ' + @SystemName + ' team.</font>'+
						N'<table border="1">' +
						N'<tr><th>Package Name</th>'+    
						N'<th>Table Name</th>' +
						N'<th>Status Change Date Time</th>'+
						CAST ( ( 
						SELECT td = [NAME], '',
						td = [Table], '',
						td = [StatusChangeDateTime] , ''
						FROM (
								SELECT  SuiteName AS [NAME],'Suite' AS [Table], [StatusChangeDateTime]
								FROM Suite
								WHERE Status = 'P'
								AND StatusChangeDateTime + CAST(MaxExpectedExecutionDuration AS datetime) < GETDATE()
								AND MaxExpectedExecutionEmailSent IS NULL
								UNION ALL
								SELECT ExtractPackageName AS [NAME], 'ExtractControl' AS [Table], [StatusChangeDateTime]
								FROM ExtractControl 
								WHERE Status = 'P'
								AND StatusChangeDateTime + CAST(MaxExpectedExecutionDuration AS datetime) < GETDATE()
								AND MaxExpectedExecutionEmailSent IS NULL
								)a
								 FOR XML PATH('tr'), TYPE 
						) AS NVARCHAR(MAX) ) +
						N'</table>' ;
						
					EXEC msdb.dbo.sp_send_dbmail 
						@recipients = @EmailReceipent,
						@subject = @Email_Subject,
						@body = @tableHTML,
						@profile_name = @ProfileName,
						@body_format = 'HTML', 
						@Importance = @Importance ;
				
					-- Update sent email date for extract control and suite
					UPDATE [ExtractControl] 
					SET [MaxExpectedExecutionEmailSent] = GETDATE()
					WHERE Status = 'P' 	
					AND StatusChangeDateTime + CAST(MaxExpectedExecutionDuration AS datetime) < GETDATE()
					AND MaxExpectedExecutionEmailSent IS NULL
										
					UPDATE Suite
					SET [MaxExpectedExecutionEmailSent] = GETDATE()
					WHERE Status = 'P'
					AND StatusChangeDateTime + CAST(MaxExpectedExecutionDuration AS datetime) < GETDATE()
					AND MaxExpectedExecutionEmailSent IS NULL
				END				
	END
END
GO
PRINT N'Creating [dbo].[spSendEmailExtractFailure]...';


GO
-- =============================================
-- Author:		Dylan Harvey/Olof Szymczak
-- Create date: 16/12/2013
-- Description:	To send the failed extract message 
-- =============================================
CREATE PROCEDURE [dbo].[spSendEmailExtractFailure]
  @EmailReceipent varchar(max) = 0,
  @LastErrorEmailChecker DATETIME,
  @ScheduleType NVARCHAR(100)
AS
BEGIN
	SET NOCOUNT ON;
    
	DECLARE @Message AS VARCHAR(MAX)
	DECLARE @LogQuery AS VARCHAR(MAX)
	DECLARE @BodyMessage AS VARCHAR(MAX)
	DECLARE @Importance AS VARCHAR(20)
	DECLARE @count int    
	DECLARE @ProfileName NVARCHAR(255)
	DECLARE @SystemName varchar(max)
	DECLARE @tableHTML  NVARCHAR(MAX) 
    DECLARE @Email_Subject NVARCHAR(255)
    
    
    -- Set variables
	SELECT @ProfileName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'EmailProfileName'
	SELECT @SystemName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'SystemName'
	SELECT @Email_Subject = '!!!Failure!!! - ' + @SystemName + ' Extract Process Failed'
	SELECT @Importance = 'High'

	--Check if a process has failed and no action has been taken
	SELECT @count = COUNT (*)
	FROM [ExtractControl] ec (NOLOCK)
					INNER JOIN  dbo.ExtractExecutionlog ecl(nolock) ON ec.ExtractControlID = ecl.ExtractControlID
					WHERE  (ecl.successflag =0 
					AND @LastErrorEmailChecker <= EndTime)
					OR ((ec.Status = 'F' AND [FailedCountEmailSent] IS NULL) -- handle hourly
                    OR (ec.Status = 'F' AND @ScheduleType = 'Daily'))

	IF @count > 0
	BEGIN 
			SET @tableHTML =
			N'<H1>'+@SystemName+' Process Failure</H1>' +
			N'<font size = "3">Hi,<br>' + CHAR(10) + CHAR(10) +
			N'<br>Please check DWReference, the status is reporting that the packages below have failed.<br>  '+
			'This will need to be investigated.' + CHAR(10) + CHAR(10) +
			N'<br>Please do not reply this email as it is auto generated from ' + @SystemName + 
			' system. If you have any questions with this email please contact ' + @SystemName + ' team.</font>'+
			N'<table border="1">' +
			N'<tr><th>ExtractControlID</th>'+    
			N'<th>SuiteName</th>' +
			N'<th>ExtractPackageName</th>' +
			N'<th>Last Status Change date time</th>'+
			N'<th>Last Package failed date time</th>'+
			N'<th>Package Status</th>'+
			N'<th>Failed Count</th>'+
			CAST ( ( 
			SELECT  CASE WHEN Status = 'F' THEN '#FF0000' 
			             ELSE '#F7FE2E'
			END AS [@bgcolor],
			td = ExtractControlID, '',
			td = SuiteName, '',
			td = ExtractPackageName, '',
			td = [StatusChangeDateTime] , '',
			td = [EndTime], '',
			td = [status] , '',
			td =  FailedCount , ''
			FROM (	
					SELECT ec.ExtractControlID,ec.ExtractPackageName, ec.[StatusChangeDateTime], MAX(ecl.EndTime) AS 'EndTime', ec.[status], ISNULL(ec.FailedCount,0) AS FailedCount, s.SuiteName
					FROM [ExtractControl] ec (NOLOCK)
					INNER JOIN dbo.Suite s (NOLOCK) ON s.SuiteID = ec.SuiteID
					INNER JOIN  dbo.ExtractExecutionlog ecl(nolock) ON ec.ExtractControlID = ecl.ExtractControlID
					WHERE  (ecl.successflag =0 
					AND @LastErrorEmailChecker <= EndTime)
					OR (ec.Status = 'F' AND [FailedCountEmailSent] IS NULL) -- handle hourly
					OR (ec.Status = 'F' AND @ScheduleType = 'Daily')
					GROUP BY ec.ExtractControlID,ec.ExtractPackageName, ec.[StatusChangeDateTime], ec.[status], ISNULL(ec.FailedCount,0), s.SuiteName
				)a
					FOR XML PATH('tr'), TYPE 
			) AS NVARCHAR(MAX) ) +
			N'</table>
<br>Legend
<table border="1">
	<tr>
		<th>Colour</th>  
		<th>Description</th>
	</tr>
	<tr><td bgcolor="#FF0000"></td><td>The package has failed and will not work until an administrator resets the status</td></tr>
	<tr><td bgcolor="#F7FE2E"></td><td>This is a warning that the package has failed but will continue to work until it hits the max fail count</td></tr>
</table>'

			EXEC	msdb.dbo.sp_send_dbmail
			@profile_name = @ProfileName,
			@recipients = @EmailReceipent,
			@body = @tableHTML,					
			@body_format = 'HTML', 
			@query = @LogQuery ,
			@subject =@Email_Subject,
			@Importance = @Importance
					
		END 			    
			
		-- Update email sent time	
		UPDATE [ExtractControl] 
		SET [FailedCountEmailSent] = GETDATE()
		WHERE Status = 'F' 	
		AND [FailedCountEmailSent] IS NULL
END
GO
PRINT N'Creating [dbo].[spGetDeliveryCompl]...';


GO



CREATE PROCEDURE [dbo].[spGetDeliveryCompl]
	@ExecutionOrder INT,
	@DeliveryJobID INT
AS
BEGIN
SET NOCOUNT ON;
	SELECT Count(DISTINCT DeliveryPackageName) AS ExecutedPackageCount 
	FROM DeliveryExecutionLog (NOLOCK) dc 
	WHERE dc.CompletedFlag = 1
	AND dc.ExecutionOrder = @ExecutionOrder
	AND dc.DeliveryJobID = @DeliveryJobID
END
GO
PRINT N'Creating [dbo].[spr_scdw_healthCheck]...';


GO

CREATE PROCEDURE [dbo].[spr_scdw_healthCheck] AS 

CREATE TABLE #Messages  
 (  
  RowNumber  INT,  
  MessageText  VARCHAR(255)  ,
  ErrorNumber INT
  
 )

DECLARE @message varchar(255)
set @message = 'SCDW Health Check for ' + convert(varchar,getdate(), 106)


INSERT INTO #Messages(RowNumber,MessageText,ErrorNumber)
values(1,@Message,0)

INSERT INTO #Messages(RowNumber,MessageText,ErrorNumber)
SELECT 2 as RowNumber,'Package ' +  [DeliveryPackageName] + ' has generated an error. Please see Delivery Execution Log for details.' as MessageText,1 as errorNumber
FROM [dbo].[DeliveryExecutionLog]
WHERE successflag = 0 and convert(varchar,starttime, 106) = convert(varchar,getdate(), 106)

IF @@ROWCOUNT <> 0
   BEGIN
   INSERT INTO #Messages(RowNumber,MessageText,ErrorNumber)
   VALUES(2,'Errors In Delivery Execution ' + convert(varchar,getdate(), 106),0)
   END
-------------------------------------------------------------------------------
-- Refactoring required as the statement below will not work due to RowsErrored column
-- been removed
-------------------------------------------------------------------------------
--INSERT INTO #Messages(RowNumber,MessageText,ErrorNumber)
--SELECT 3 as RowNumber
--      ,'Package ' +  [DeliveryPackageName] + ' has sent rows to Error. Rows Delivered: ' + Cast([RowsDelivered] as varchar)
--      + ' Error Rows: ' + cast([RowsErrored] as varchar)  as MessageText
--      ,2 as ErrorNumber
--  FROM [dbo].[DeliveryExecutionLog]
--  WHERE RowsErrored > 0 and convert(varchar,starttime, 106) = convert(varchar,getdate(), 106)
IF @@ROWCOUNT <> 0
   BEGIN
   INSERT INTO #Messages(RowNumber,MessageText,ErrorNumber)
   VALUES(3,'Error Rows Generated In Delivery Execution ' + convert(varchar,getdate(), 106),0)
   END

INSERT INTO #Messages(RowNumber,MessageText,ErrorNumber)
SELECT
4 as RowNumber,'Package ' +  [ExtractPackageName] + ' has generated an error. Please see Extract Execution Log for details.' as MessageText,3 as errorNumber
  FROM [dbo].[ExtractExecutionLog]
WHERE convert(varchar,starttime, 106) = convert(varchar,getdate(), 106) and SuccessFlag = 0

IF @@ROWCOUNT <> 0
   BEGIN
   INSERT INTO #Messages(RowNumber,MessageText,ErrorNumber)
   VALUES(4,'Errors Generated In Extract Execution ' + convert(varchar,getdate(), 106),0)
   END

SELECT MessageText
FROM #Messages 
ORDER BY ROWNUMBER,ErrorNumber
GO
PRINT N'Creating [dbo].[spGetExtractExecutionOrder]...';


GO
-- =============================================
-- Author:	oszymczak
-- Create date: 11/10/2010
-- Description:	Get the Execution Order List For the specified Suite 
-- =============================================
CREATE PROCEDURE [dbo].[spGetExtractExecutionOrder]
	@SuiteName VARCHAR(50),
	@ExecutionOrderGroup INT
AS
BEGIN
	SET NOCOUNT ON;
	
	SELECT DISTINCT ExecutionOrder, Count(*) AS PackageCount 
	FROM ExtractControl ec (NOLOCK) 
	INNER JOIN dbo.Suite s (NOLOCK) ON ec.SuiteID = s.SuiteID
	WHERE  s.SuiteName = @SuiteName
	AND ec.Status = 'S'
	AND ec.NextRunDateTime <= GETDATE()
	AND ec.ExecutionOrderGroup = @ExecutionOrderGroup
	GROUP BY ExecutionOrder
	ORDER BY ExecutionOrder
END
GO
PRINT N'Creating [dbo].[spGetExtractExecutionVariables]...';


GO

-- =============================================
-- Author:	oszymczak
-- Create date: 03/08/2011
-- Description:	Get Extract Execution
-- =============================================
CREATE PROCEDURE [dbo].[spGetExtractExecutionVariables]
AS
BEGIN
	SET NOCOUNT ON

SELECT
scMSDB.ConfiguredValue AS 'ConnStr_msdb',
scSrv.ConfiguredValue AS  'Server'
FROM dbo.SSISConfiguration scMSDB 
INNER JOIN dbo.SSISConfiguration scSrv ON scSrv.ConfigurationFilter = 'Server'
WHERE scMSDB.ConfigurationFilter = 'ConnStr_msdb'
END
GO
PRINT N'Creating [dbo].[spGetExtractExecutionSqlVariables]...';


GO
-- =============================================
-- Author:	oszymczak
-- Create date: 03/08/2011
-- Description:	Get Extract Execution Sql Variables
-- =============================================
CREATE PROCEDURE [dbo].[spGetExtractExecutionSqlVariables]
	@ExtractControlID INT
AS
BEGIN
	SET NOCOUNT ON;
SELECT
scSource.SourceName,
scDestination.SourceName AS 'DestinationName',
sscSource.ConfiguredValue AS 'ConnStr_Source',
sscDestination.ConfiguredValue AS 'ConnStr_Destination'
FROM dbo.ExtractControl ec 
INNER JOIN dbo.SourceControl scSource ON ec.SourceControlID = scSource.SourceControlID
INNER JOIN dbo.SSISConfiguration sscSource ON sscSource.SSISConfigurationID = scSource.SSISConfigurationID
INNER JOIN dbo.SourceControl scDestination ON ec.DestinationControlID = scDestination.SourceControlID
INNER JOIN dbo.SSISConfiguration sscDestination ON sscDestination.SSISConfigurationID = scDestination.SSISConfigurationID

WHERE ec.ExtractControlID = @ExtractControlID
END
GO
PRINT N'Creating [dbo].[spGetExtractManagerVariables]...';


GO

-------------------------------------------------------------------------------
-- Author:	oszymczak
-- Create date: 2013/08/19
-- Description:	Returns Extract Manager Variables
-------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[spGetExtractManagerVariables]
AS
BEGIN
SET NOCOUNT ON

SELECT scEnv.ConfiguredValue AS  'Environment',
scSrv.ConfiguredValue AS  'Server',
dbo.udfPackagePathName(scEnv.ConfiguredValue, SUBSTRING(scDel.ConfiguredValue, 0, CHARINDEX('\', scDel.ConfiguredValue, 2)), SUBSTRING(scDel.ConfiguredValue, CHARINDEX('\', scDel.ConfiguredValue, 2) + 1, LEN(scDel.ConfiguredValue) - CHARINDEX('\', scDel.ConfiguredValue, 2))) AS 'ExtractExecutionLocation',
scMSDB.ConfiguredValue AS 'ConnStr_msdb'
FROM dbo.SSISConfiguration scEnv
INNER JOIN dbo.SSISConfiguration scSrv ON scSrv.ConfigurationFilter = 'Server'
INNER JOIN dbo.SSISConfiguration scDel ON scDel.ConfigurationFilter = 'ExtractExecutionLocation'
INNER JOIN dbo.SSISConfiguration scMSDB ON scMSDB.ConfigurationFilter = 'ConnStr_msdb'
WHERE scEnv.ConfigurationFilter = 'Environment'
END
GO
PRINT N'Creating [dbo].[spGetDeliveryManagerVariables]...';


GO

-------------------------------------------------------------------------------
-- Author:	oszymczak
-- Create date: 2013/08/19
-- Description:	Returns Delivery Manager Variables
-------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[spGetDeliveryManagerVariables]
AS
BEGIN
SET NOCOUNT ON

SELECT scEnv.ConfiguredValue AS  'Environment',
scSrv.ConfiguredValue AS  'Server',
dbo.udfPackagePathName(scEnv.ConfiguredValue, SUBSTRING(scDel.ConfiguredValue, 0, CHARINDEX('\', scDel.ConfiguredValue, 2)), SUBSTRING(scDel.ConfiguredValue, CHARINDEX('\', scDel.ConfiguredValue, 2) + 1, LEN(scDel.ConfiguredValue) - CHARINDEX('\', scDel.ConfiguredValue, 2))) AS 'DeliveryExecutionLocation',
scMSDB.ConfiguredValue AS 'ConnStr_msdb'
FROM dbo.SSISConfiguration scEnv
INNER JOIN dbo.SSISConfiguration scSrv ON scSrv.ConfigurationFilter = 'Server'
INNER JOIN dbo.SSISConfiguration scDel ON scDel.ConfigurationFilter = 'DeliveryExecutionLocation'
INNER JOIN dbo.SSISConfiguration scMSDB ON scMSDB.ConfigurationFilter = 'ConnStr_msdb'
WHERE scEnv.ConfigurationFilter = 'Environment'
END
GO
PRINT N'Creating [dbo].[spGetExtractPackages]...';


GO



-- =============================================
-- Author:	oszymczak
-- Create date: 03/08/2011
-- Description:	Get the Extract Packages based on Exectuion Order and Suite 
-- =============================================
CREATE PROCEDURE [dbo].[spGetExtractPackages]
	@SuiteName VARCHAR(50),
	@ExecutionOrder INT,
	@ExecutionOrderGroup INT
AS
BEGIN
	SET NOCOUNT ON;
	
	SELECT DISTINCT sc.AccessWindowStartMins, ec.ExtractControlID, ec.ExtractPackageName, COALESCE(ec.RunAs32Bit, 'False') AS RunAs32bit
	FROM 
	dbo.SourceControl sc (NOLOCK)
	INNER JOIN dbo.ExtractControl ec (NOLOCK)  ON sc.SourceControlID = ec.SourceControlID
	INNER JOIN dbo.Suite s (NOLOCK) ON ec.SuiteID = s.SuiteID
	WHERE	
	s.SuiteName = @SuiteName
	AND ec.ExecutionOrder = @ExecutionOrder
	AND ec.NextRunDateTime <= GETDATE()
	AND ec.Status = 'S'
	AND ec.ExecutionOrderGroup = @ExecutionOrderGroup
	ORDER BY 
	sc.AccessWindowStartMins	
END
GO
PRINT N'Creating [dbo].[spGetExtractSuites]...';


GO
-- =============================================
-- Author:	oszymczak
-- Create date: 03/08/2011
-- Description:	Get Extract Suites
-- =============================================
CREATE PROCEDURE [dbo].[spGetExtractSuites]
	@ExecutionOrderGroup INT
AS
BEGIN
	SET NOCOUNT ON;
-------------------------------------------------------------------------------
-- Ensure that the same suite cannot run concurrently
-------------------------------------------------------------------------------	
	DECLARE @StatusChangeDateTime DATETIME = GETDATE()
	
	UPDATE dbo.Suite SET Status = 'P', StatusChangeDateTime = @StatusChangeDateTime
	FROM  dbo.Suite s (NOLOCK)
	INNER JOIN dbo.ExtractControl ec (NOLOCK) ON s.SuiteID = ec.SuiteID
	WHERE ec.NextRunDateTime <= GETDATE()
	AND ec.Status = 'S'
	AND s.Status = 'S'
	AND ec.ExecutionOrderGroup = @ExecutionOrderGroup
	
-------------------------------------------------------------------------------	
-- Return result
-------------------------------------------------------------------------------		
	SELECT DISTINCT s.SuiteName AS 'Suite'
	FROM dbo.Suite s (NOLOCK)
	INNER JOIN dbo.ExtractControl ec (NOLOCK) ON s.SuiteID = ec.SuiteID	
	WHERE ec.NextRunDateTime <= GETDATE()
	AND ec.Status = 'S'
	AND s.Status = 'P'
	AND s.StatusChangeDateTime = @StatusChangeDateTime
	AND ec.ExecutionOrderGroup = @ExecutionOrderGroup
	GROUP BY s.SuiteName
	ORDER BY s.SuiteName
END
GO
PRINT N'Creating [dbo].[spGetLogilityExtractUploadVariables]...';


GO


-- =============================================
-- Author:	oszymczak
-- Create date: 13/09/2011
-- Description:	Get Logility Extract Upload Variables
-- =============================================
CREATE PROCEDURE [dbo].[spGetLogilityExtractUploadVariables]
	@CountryCode NVARCHAR(3)
AS
BEGIN
	SET NOCOUNT ON;
	
	DECLARE @FileDir           NVARCHAR(255)
	DECLARE @Email             NVARCHAR(255)
	DECLARE @MasterDataConnStr NVARCHAR(255)
	DECLARE @LogilityConnStr   NVARCHAR(255)
	DECLARE @SMTPServerConnStr NVARCHAR(255)

	SELECT @FileDir           = ConfiguredValue    FROM dbo.SSISConfiguration WHERE ConfigurationFilter = 'FileDir_Logility_Extract_Upload'
	SELECT @Email             = ConfiguredValue    FROM dbo.SSISConfiguration WHERE ConfigurationFilter = 'Email_Logility_Extract_Upload'
	SELECT @MasterDataConnStr = ConfiguredValue    FROM dbo.SSISConfiguration WHERE ConfigurationFilter = 'ConnStr_RegDistExtract_DB'
	SELECT @LogilityConnStr   = sc.ConfiguredValue FROM dbo.SSISConfiguration sc
	       INNER JOIN dbo.SSISConfiguration scCountry
	       ON scCountry.ConfiguredValue = sc.ConfigurationFilter
	 WHERE scCountry.ConfigurationFilter = ('Logility_' + @CountryCode)
	SELECT @SMTPServerConnStr = ConfiguredValue    FROM dbo.SSISConfiguration WHERE ConfigurationFilter = 'ConnStr_SMTP_Server'

	SELECT @FileDir           AS 'FileDir',
           @Email             AS 'Email',
           @MasterDataConnStr AS 'MasterDataConnStr',
           @LogilityConnStr   AS 'LogilityConnStr',
           @SMTPServerConnStr AS 'SMTPServerConnStr'
	
END
GO
PRINT N'Creating [dbo].[spCheckOutageWindow]...';


GO
CREATE PROCEDURE [dbo].[spCheckOutageWindow] 
@CheckDate DATETIME
AS
BEGIN

SELECT COUNT(DISTINCT 1) AS 'IsOutageWindowActive'
FROM [dbo].[ScheduleOutageWindow]
WHERE @CheckDate BETWEEN [StartDateTime] AND [EndDateTime]

END
GO
PRINT N'Creating [dbo].[spGetSourceControl]...';


GO
CREATE PROCEDURE [dbo].[spGetSourceControl] 
@SourceName VARCHAR(50)

AS
BEGIN
	SET NOCOUNT ON;

	SELECT scon.ConfiguredValue FROM dbo.SourceControl sc
	INNER JOIN dbo.SSISConfiguration scon ON sc.SSISConfigurationID = scon.SSISConfigurationID
	WHERE sc.SourceName = @SourceName
END
GO
PRINT N'Creating [dbo].[spUpdateExtractSuiteStatus]...';


GO

CREATE PROCEDURE [dbo].[spUpdateExtractSuiteStatus]
	@SuiteName VARCHAR(50),
	@Status CHAR(1)	
AS
BEGIN 
IF @Status = 'F'
	BEGIN
		UPDATE Suite SET Status = @Status,
		StatusChangeDateTime = GETDATE()
		WHERE SuiteName = @SuiteName
	END
ELSE IF @Status IN ('S', 'P')	
	BEGIN
		UPDATE Suite SET Status = @Status,
		StatusChangeDateTime = GETDATE(),
		MaxExpectedExecutionEmailSent = NULL
		WHERE SuiteName = @SuiteName	
	END
END
GO
PRINT N'Creating [dbo].[spGetDeliveryExecutionVariables]...';


GO
-- =============================================
-- Author:	oszymczak
-- Create date: 03/08/2011
-- Description:	Get Delivery Execution Variables
-- =============================================
CREATE PROCEDURE [dbo].[spGetDeliveryExecutionVariables]
	@DeliveryControlID INT
AS
BEGIN
SET NOCOUNT ON;

SELECT 
CONVERT(CHAR(23), GETDATE(), 121) AS StartTime,
DeliveryPackagePath,
DeliveryPackageName,
DeliveryTable,
ExtractTable,
ErrorTable,
ExecutionOrder,
ProcessType,
CONVERT(CHAR(23), LastExecutionTime, 121) AS LastExecutionTime,
LastExtractJobID,
scMSDB.ConfiguredValue AS ConnStr_msdb,
scExtract.ConfiguredValue AS  ConnStr_Extract,
scDW.ConfiguredValue AS  ConnStr_DW,
scEnv.ConfiguredValue AS  Environment,
dbo.udfPackagePathName(scEnv.ConfiguredValue, dc.DeliveryPackagePath, dc.DeliveryPackageName) AS 'DerivedPathAndName',
dc.InsertOnly
FROM 
DeliveryControl  dc
INNER JOIN dbo.SSISConfiguration scMSDB ON scMSDB.ConfigurationFilter = 'ConnStr_msdb'
INNER JOIN dbo.SSISConfiguration scExtract ON scExtract.ConfigurationFilter = 'ConnStr_DWExtract_DB'
INNER JOIN dbo.SSISConfiguration scDW ON scDW.ConfigurationFilter = 'ConnStr_DWData_DB'
INNER JOIN dbo.SSISConfiguration scEnv ON scEnv.ConfigurationFilter = 'Environment'
WHERE
DeliveryControlID = @DeliveryControlID
END
GO
PRINT N'Creating [dbo].[spGetJobID]...';


GO



CREATE PROCEDURE [dbo].[spGetJobID] 
	-- Add the parameters for the stored procedure here
	@Type varchar(50)  
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF @Type = 'DeliveryJobID' OR @Type = 'ExtractJobID' OR @Type = 'SummaryJobID' OR @Type = 'StagingJobID'
	BEGIN
		BEGIN TRAN  
			--Increment the JobID
			DECLARE @ETLParameterValue TABLE
			(
			  JobID NVARCHAR(100)
			);
			
			UPDATE ETLParameters
			SET ETLParameterValue = CAST((CAST(ETLParameterValue AS INT) + 1) AS VARCHAR(50))
			OUTPUT INSERTED.ETLParameterValue
			INTO @ETLParameterValue
			WHERE ETLParameterName = @Type
			
			SELECT CAST(JobID AS INT) AS 'JobID' FROM @ETLParameterValue
		COMMIT TRAN
	END 
END
GO
PRINT N'Creating [dbo].[GetPreProcessJobID]...';


GO
-- =============================================
-- Author:		Irwan Iswadi
-- Create date: 15 May 2009
-- Description:	To get the Pre process job id
-- =============================================
CREATE PROCEDURE [dbo].[GetPreProcessJobID] 
	-- Add the parameters for the stored procedure here

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	UPDATE ETLParameters
	SET ETLParameterValue = CAST((CAST(ETLParameterValue AS INT) + 1) AS VARCHAR(50))
	WHERE ETLParameterName = 'PreProcessJobID'


		-- Insert statements for procedure here
	SELECT CAST(ETLParameterValue AS INT) AS PreProcessJobID 
	FROM ETLParameters WHERE ETLParameterName = 'PreProcessJobID'	

    -- Insert statements for procedure here

END
GO
PRINT N'Creating [dbo].[spGetExtractCompl]...';


GO

CREATE PROCEDURE [dbo].[spGetExtractCompl]
	@SuiteName VARCHAR(50),
	@ExecutuionOrder INT,
	@ExtractJobID INT
AS
BEGIN
SET NOCOUNT ON;

SELECT Count(DISTINCT ExtractControlID) AS ExecutedPackageCount 
FROM ExtractExecutionLog (NOLOCK) ec 
INNER JOIN dbo.Suite s ON ec.SuiteID = s.SuiteID
WHERE ec.CompletedFlag = 1
AND s.SuiteName = @SuiteName
AND ec.ExecutionOrder = @ExecutuionOrder
AND ec.ExtractJobID = @ExtractJobID
END
GO
PRINT N'Creating [dbo].[spInsertDeliveryExecutionLog]...';


GO

-------------------------------------------------------------------------------
-- Author:	oszymczak
-- Create date: 2013/08/19
-- Description:	Return packages that will be executed based on ScheduleType 
--              and ExecutionOrder
-------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[spInsertDeliveryExecutionLog]
	@DeliveryControlID INT
	,@DeliveryJobID INT
    ,@ExtractJobID INT
    ,@StartTime DATETIME
    ,@ManagerGUID UNIQUEIDENTIFIER
    ,@SuccessFlag INT
    ,@CompletedFlag INT
    ,@MessageSource VARCHAR(1000)
    ,@Message VARCHAR(1000)
    ,@RowsDelivered INT
    ,@RowsErrored INT  
    ,@LastExecutionTime DATETIME
    ,@NextLastExecutionTime DATETIME
    ,@DeliveryPackagePathAndName VARCHAR(250)
    
AS
BEGIN
SET NOCOUNT ON;

DECLARE @DeliveryPackageName VARCHAR(100)
DECLARE @DeliveryPackagePath VARCHAR(100)
DECLARE @ExecutionOrder INT
DECLARE @ScheduleType VARCHAR(100)

SELECT @DeliveryPackageName = DeliveryPackageName, @DeliveryPackagePath = DeliveryPackagePath,
@ExecutionOrder = ExecutionOrder, @ScheduleType = ScheduleType
FROM dbo.DeliveryControl WHERE DeliveryControlID = @DeliveryControlID

INSERT INTO DeliveryExecutionLog
           (DeliveryControlID
		   ,DeliveryJobID
		   ,ExtractJobID
           ,StartTime
           ,EndTime
		   ,ManagerGUID
           ,SuccessFlag
		   ,CompletedFlag
           ,MessageSource
           ,Message
           ,RowsDelivered
		   ,RowsErrored
           ,LastExecutionTime
           ,NextLastExecutionTime
		   ,DeliveryPackagePathAndName
		   ,DeliveryPackageName
		   ,DeliveryPackagePath
		   ,ExecutionOrder
		   ,ScheduleType
          )
     VALUES
           (@DeliveryControlID
		   ,@DeliveryJobID
		   ,@ExtractJobID
           ,@StartTime
           ,GETDATE()
		   ,@ManagerGUID
           ,@SuccessFlag
		   ,@CompletedFlag
           ,@MessageSource
           ,@Message
           ,@RowsDelivered
		   ,@RowsErrored
           ,@LastExecutionTime
           ,@NextLastExecutionTime
		   ,@DeliveryPackagePathAndName
		   ,@DeliveryPackageName
		   ,@DeliveryPackagePath
		   ,@ExecutionOrder
		   ,@ScheduleType
           )
END
GO
PRINT N'Creating [dbo].[spGetSummaryCompl]...';


GO
CREATE PROCEDURE [dbo].[spGetSummaryCompl]
	@ExecutuionOrder INT,
	@SummaryJobID INT
AS
BEGIN
SET NOCOUNT ON;
	SELECT Count(DISTINCT SummaryPackageName) AS ExecutedPackageCount 
	FROM SummaryExecutionLog (NOLOCK) sc 
	WHERE sc.CompletedFlag = 1
	AND sc.ExecutionOrder = @ExecutuionOrder
	AND sc.SummaryJobID = @SummaryJobID
END
GO
PRINT N'Creating [dbo].[spGetSummaryExecutionStandardVariables]...';


GO
CREATE PROCEDURE [dbo].[spGetSummaryExecutionStandardVariables]
	@SummaryControlID INT
AS
BEGIN
	SET NOCOUNT ON;
-------------------------------------------------------------------------------
-- Retrieve values
-------------------------------------------------------------------------------
SELECT
sc.[SummaryPackageName],
sc.[SummaryPackagePath],
sc.[SummaryTableName],
sc.[SourceQuery],
sc.[Type],
sc.[ScheduleType],
dbo.udfPackagePathName(scEnv.ConfiguredValue, sc.SummaryPackagePath, sc.SummaryPackageName) AS 'SummaryPathAndName',
sscSource.ConfiguredValue AS 'ConnStr_Source',
scMSDB.ConfiguredValue AS 'ConnStr_msdb',
CONVERT(CHAR(23), sc.LastExecutionTime, 121) AS LastExecutionTime
FROM dbo.SummaryControl sc 
INNER JOIN dbo.SourceControl scSource ON sc.SourceControlID = scSource.SourceControlID
INNER JOIN dbo.SSISConfiguration sscSource ON sscSource.SSISConfigurationID = scSource.SSISConfigurationID
INNER JOIN dbo.SSISConfiguration scEnv ON scEnv.ConfigurationFilter = 'Environment'
INNER JOIN dbo.SSISConfiguration scSrv ON scSrv.ConfigurationFilter = 'Server'
INNER JOIN dbo.SSISConfiguration scMSDB ON scMSDB.ConfigurationFilter = 'ConnStr_msdb'
WHERE sc.SummaryControlID = @SummaryControlID
END
GO
PRINT N'Creating [dbo].[spGetSummaryManagerPackages]...';


GO
-------------------------------------------------------------------------------
-- Author:	oszymczak
-- Create date: 2013/08/19
-- Description:	Return packages that will be executed based on ScheduleType 
--              and ExecutionOrder
-------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[spGetSummaryManagerPackages]
	@ScheduleType VARCHAR(100),
	@ExecutionOrder INT
AS
BEGIN
SET NOCOUNT ON;

SELECT SummaryControlID
FROM SummaryControl
WHERE ScheduleType = @ScheduleType
AND ExecutionOrder = @ExecutionOrder
AND ISNULL(LastDeliveryJobID, -1) <> ISNULL(CurrentDeliveryJobID, -1)
END
GO
PRINT N'Creating [dbo].[spGetSummaryManagerVariables]...';


GO


-------------------------------------------------------------------------------
-- Author:	oszymczak
-- Create date: 2013/08/19
-- Description:	Returns Summary Manager Variables
-------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[spGetSummaryManagerVariables]
AS
BEGIN
SET NOCOUNT ON

SELECT scEnv.ConfiguredValue AS  'Environment',
scSrv.ConfiguredValue AS  'Server',
dbo.udfPackagePathName(scEnv.ConfiguredValue, SUBSTRING(scExec.ConfiguredValue, 0, CHARINDEX('\', scExec.ConfiguredValue, 2)), SUBSTRING(scExec.ConfiguredValue, CHARINDEX('\', scExec.ConfiguredValue, 2) + 1, LEN(scExec.ConfiguredValue) - CHARINDEX('\', scExec.ConfiguredValue, 2))) AS 'SummaryExecutionLocation',
scMSDB.ConfiguredValue AS 'ConnStr_msdb'
FROM dbo.SSISConfiguration scEnv
INNER JOIN dbo.SSISConfiguration scSrv ON scSrv.ConfigurationFilter = 'Server'
INNER JOIN dbo.SSISConfiguration scExec ON scExec.ConfigurationFilter = 'SummaryExecutionLocation'
INNER JOIN dbo.SSISConfiguration scMSDB ON scMSDB.ConfigurationFilter = 'ConnStr_msdb'
WHERE scEnv.ConfigurationFilter = 'Environment'
END
GO
PRINT N'Creating [dbo].[spInsertSummaryExecutionLog]...';


GO

-------------------------------------------------------------------------------
-- Author:	oszymczak
-- Create date: 2013/11/13
-- Description:	log summary execution
-------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[spInsertSummaryExecutionLog]
	@SummaryControlID INT
	,@SummaryJobID INT
    ,@DeliveryJobID INT
    ,@StartTime DATETIME
    ,@ManagerGUID UNIQUEIDENTIFIER
    ,@SuccessFlag INT
    ,@CompletedFlag INT
    ,@MessageSource VARCHAR(1000)
    ,@Message VARCHAR(1000)
	,@RowsSummarized INT
AS
BEGIN
SET NOCOUNT ON;

DECLARE @SummaryPackageName VARCHAR(100)
DECLARE @SummaryTableName VARCHAR(100)
DECLARE @ExecutionOrder INT
DECLARE @Type VARCHAR(100)
DECLARE @ScheduleType VARCHAR(50)
DECLARE @SourceControlID INT
DECLARE @SourceControlValue VARCHAR(255)

SELECT @SummaryPackageName = sc.SummaryPackageName, @SummaryTableName = sc.SummaryTableName,
@ExecutionOrder = sc.ExecutionOrder, @Type = sc.[Type], @ScheduleType = sc.[ScheduleType], @SourceControlID = sc.SourceControlID,
@SourceControlValue = SourceSSC.ConfiguredValue
FROM [dbo].[SummaryControl] sc
INNER JOIN dbo.SourceControl SourceSC ON sc.SourceControlID = SourceSC.SourceControlID
INNER JOIN dbo.SSISConfiguration SourceSSC ON SourceSC.SSISConfigurationID = SourceSSC.SSISConfigurationID
WHERE SummaryControlID = @SummaryControlID

INSERT INTO [dbo].[SummaryExecutionLog]
           ([SummaryControlID]
		   ,[SummaryJobID]
           ,[DeliveryJobID]
           ,[SummaryPackageName]
		   ,SummaryTableName
           ,[StartTime]
           ,[EndTime]
		   ,[ManagerGUID]
           ,[SuccessFlag]
           ,[CompletedFlag]
           ,[MessageSource]
           ,[Message]
           ,[ScheduleType]
           ,[ExecutionOrder]
           ,[SourceControlID]
           ,[SourceControlValue]
		   ,[Type]
		   ,RowsSummarized)
     VALUES
           (@SummaryControlID
		   ,@SummaryJobID
           ,@DeliveryJobID
           ,@SummaryPackageName
		   ,@SummaryTableName
           ,@StartTime
           ,GETDATE()
		   ,@ManagerGUID
           ,@SuccessFlag
           ,@CompletedFlag
           ,@MessageSource
           ,@Message
           ,@ScheduleType
           ,@ExecutionOrder
           ,@SourceControlID
           ,@SourceControlValue
		   ,@Type
		   ,@RowsSummarized)

IF @SuccessFlag = 1 AND @CompletedFlag = 1
BEGIN
	UPDATE [SummaryControl]
	SET LastDeliveryJobID = @DeliveryJobID
	,LastSummaryJobID = @SummaryJobID
	,LastExecutionTime = GETDATE()
	WHERE SummaryControlID = @SummaryControlID
END

END
GO
PRINT N'Creating [dbo].[spSendEmailFailedLogToday]...';


GO

/**************************************************************************************************************

Author		:	Preethi Khatore
Create date	:	2 Nov 2009
Description	:	To send the failed process summary message 

Altered		:	Dylan Harvey
Date		:	20120912
Description	:	Removed logic for 'WithOutCubeBuilt' and call new stored proc



**************************************************************************************************************/
CREATE  PROCEDURE [dbo].[spSendEmailFailedLogToday] 
	-- Add the parameters for the stored procedure here
	@RecipientEmail varchar(max) = 0,
	@SystemName varchar(max) = 0,
	@CubeBuiltStatus varchar(50) ='WithOutCubeBuilt'
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
  -- DECLARE	@RecipientEmail varchar(max) = 'Preethi.khatore@brightstarcorp.com'
	--DECLARE @SystemName varchar(max) = 'UAT Regional Distribution'
    
    DECLARE @SuccessMessage AS VARCHAR(MAX)
    DECLARE @LogQuery AS VARCHAR(MAX)
    DECLARE @BodyMessage AS VARCHAR(MAX)
    DECLARE @Importance AS VARCHAR(20)
    DECLARE @CubeBuiltcompletestatus AS VARCHAR(50) = @CubeBuiltStatus
    declare @count int
    
    DECLARE @ProfileName NVARCHAR(255)
	SELECT @ProfileName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'EmailProfileName'
    
     If @CubeBuiltcompletestatus='WithCubeBuiltCompleted'
    BEGIN
    SELECT @SuccessMessage = 
				CASE 
					WHEN COUNT(*) = 0 
					THEN @SystemName + ' Process Log Summary - No Error Found' 
					ELSE 'FAILURE '+@SystemName + ' Process Log Summary!' END,
		   @Importance =
				CASE 
					WHEN COUNT(*) > 0 
					THEN 'High' 
					ELSE 'Normal' END,
		   @BodyMessage	= 'Hi'+ CHAR(10) + CHAR(10) +
				'Please do not reply this email as it is auto generated from ' + @SystemName + ' system. If you have any questions with this email please contact ' + @SystemName + ' team.' + CHAR(10) + CHAR(10) +
				CASE
					WHEN COUNT(*) = 0 
					THEN 'Please ignore the attachment as there is no error found.'
					ELSE  'Please check the attachment file as there are errors found in ' + 	@SystemName
				END + CHAR(10) + CHAR(10)
    FROM vi_FailedLogToday
    
    SET @LogQuery =  'SET NOCOUNT ON; SELECT * FROM RegDistETLReference.dbo.vi_FailedLogToday'
    
   -- select @count=COUNT(*) from vi_FailedLogToday
    
     EXEC msdb.dbo.sp_send_dbmail
    @profile_name = @ProfileName,
    @recipients = @RecipientEmail,
    @body = @BodyMessage,
    @query = @LogQuery ,
    @subject =@SuccessMessage,
    @Importance = @Importance,
    @attach_query_result_as_file = 1,
    @query_result_no_padding = 0

END
ELSE IF @CubeBuiltcompletestatus='WithOutCubeBuilt'
	----If @CubeBuiltcompletestatus='WithOutCubeBuilt'



	 --DH 20120912 Replaced with new stored proc

	 BEGIN
	   SELECT @SuccessMessage = 
				CASE 
					WHEN COUNT(*) = 0 
					THEN @SystemName + ' Process Log Summary - No Error Found' 
					ELSE 'FAILURE '+@SystemName + ' Process Log Summary!' END,
		   @Importance =
				CASE 
					WHEN COUNT(*) > 0 
					THEN 'High' 
					ELSE 'Normal' END,
		   @BodyMessage	= 'Hi'+ CHAR(10) + CHAR(10) +
				'Please do not reply this email as it is auto generated from ' + @SystemName + ' system. If you have any questions with this email please contact ' + @SystemName + ' team.' + CHAR(10) + CHAR(10) +
				CASE
					WHEN COUNT(*) = 0 
					THEN 'Please ignore the attachment as there is no error found.'
					ELSE  'Please check the attachment file as there are errors found in ' + 	@SystemName
				END + CHAR(10) + CHAR(10)
	   FROM vi_FailedLogToday_Extractonly

	   SET @LogQuery =  'SET NOCOUNT ON; SELECT * FROM RegDistETLReference.dbo.vi_FailedLogToday_Extractonly'

	    select @count=COUNT(*)
	     from vi_FailedLogToday_Extractonly

	    --- Only if any error records exist
	    if @count>0


	   EXEC msdb.dbo.sp_send_dbmail
	   @profile_name = @ProfileName,
	   @recipients = @RecipientEmail,
	   @body = @BodyMessage,
	   @query = @LogQuery ,
	   @subject =@SuccessMessage,
	   @Importance = @Importance,
	   @attach_query_result_as_file = 1,
	   @query_result_no_padding = 0


	END
 ELSE 
	BEGIN 
	EXEC [spSendEmailExtractFailure] @RecipientEmail,	@SystemName ,'Now'
	END
END
GO
PRINT N'Creating [dbo].[spUpdateSummaryControlCurrentDeliveryJobID]...';


GO

CREATE PROCEDURE [dbo].[spUpdateSummaryControlCurrentDeliveryJobID]
	@ScheduleType VARCHAR(100)
AS
BEGIN
SET NOCOUNT ON
DECLARE @SummaryPackageName NVARCHAR(100)
DECLARE @SourceDatabaseName NVARCHAR(500)
DECLARE @ConnStr NVARCHAR(500)


DECLARE @sqlGen NVARCHAR(MAX) = ''



DECLARE curPackages CURSOR FOR
SELECT s.SummaryPackageName, ss.ConfiguredValue FROM [dbo].[SummaryControl] s 
INNER JOIN [dbo].SourceControl sc ON s.SourceControlID = sc.SourceControlID
INNER JOIN [dbo].SSISConfiguration ss ON sc.SSISConfigurationID = ss.SSISConfigurationID
OPEN curPackages
FETCH NEXT FROM curPackages INTO @SummaryPackageName, @ConnStr
WHILE (@@FETCH_STATUS = 0)
BEGIN

	SET @SourceDatabaseName = SUBSTRING(@ConnStr, 
	                                CHARINDEX('Initial Catalog', @ConnStr), 
						            CHARINDEX(';', @ConnStr, CHARINDEX('Initial Catalog', @ConnStr))- CHARINDEX('Initial Catalog', @ConnStr))
	SET @SourceDatabaseName = LTRIM(RTRIM(SUBSTRING(@SourceDatabaseName, CHARINDEX('=',@SourceDatabaseName) +1, LEN(@SourceDatabaseName))))

	SET @sqlGen = '
	DECLARE @FirstRun BIT = 1
	DECLARE @NoDpendancy BIT = 1
	DECLARE @TableName NVARCHAR(100) = ''''
	DECLARE @sqlQuery NVARCHAR(MAX) = ''''
	SET @sqlQuery = ''DECLARE @DeliveryJobID INT
	SELECT @DeliveryJobID = MAX(DeliveryJobID) FROM (''

	DECLARE cur CURSOR FOR
	SELECT DISTINCT referenced_schema_name + ''.'' + referenced_entity_name AS ''TableName''
	FROM ' + @SourceDatabaseName + '.sys.dm_sql_referenced_entities (''' + @SummaryPackageName + ''', ''OBJECT'') re
	INNER JOIN ' + @SourceDatabaseName + '.INFORMATION_SCHEMA.COLUMNS c ON c.TABLE_SCHEMA = re.referenced_schema_name AND c.TABLE_NAME = re.referenced_entity_name
	WHERE c.COLUMN_NAME = ''DeliveryJobID''
	OPEN cur
	FETCH NEXT FROM cur INTO @TableName
	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		SET @NoDpendancy = 0
		IF @FirstRun = 1
		BEGIN
			SET @FirstRun = 0
		END
		ELSE
		BEGIN
			SET @sqlQuery = @sqlQuery + '' UNION ALL
	''
		END
		SET @sqlQuery = @sqlQuery + ''SELECT MAX(DeliveryJobID) AS ''''DeliveryJobID'''' FROM ' + @SourceDatabaseName + '.'' + @TableName


		FETCH NEXT FROM cur INTO @TableName
	END
	CLOSE cur
	DEALLOCATE cur
	
	SET  @sqlQuery = @sqlQuery + ''
	) a

	UPDATE [dbo].[SummaryControl] SET [CurrentDeliveryJobID] = @DeliveryJobID WHERE [SummaryPackageName] = ''''' + @SummaryPackageName + '''''''
	IF @NoDpendancy = 0
	BEGIN 
		EXEC sp_executesql @sqlQuery
	END'

	EXEC sp_executesql @sqlGen

	FETCH NEXT FROM curPackages INTO @SummaryPackageName, @ConnStr
END
CLOSE curPackages
DEALLOCATE curPackages
	
------------------------------------------------------------------------------
-- 2.0 Return if there are any changes requiring Summary manager to process.
------------------------------------------------------------------------------
	SELECT ISNULL(MAX(ABS([LastDeliveryJobID] - [CurrentDeliveryJobID])), 0) AS 'ChangesFound' FROM [dbo].[SummaryControl] WHERE ISNULL([LastDeliveryJobID], -1) <> ISNULL([CurrentDeliveryJobID], -1) AND ScheduleType = @ScheduleType
END
GO
PRINT N'Creating [dbo].[spUpdateDeliveryControlCurrentExtractJobID]...';


GO




CREATE PROCEDURE [dbo].[spUpdateDeliveryControlCurrentExtractJobID]
AS
BEGIN
	SET NOCOUNT ON
	DECLARE @FullExtractTable NVARCHAR(100)
	DECLARE @SqlQuery NVARCHAR(MAX)
	DECLARE @SourceControlID INT
	DECLARE @ExtractTable NVARCHAR(200)

	CREATE TABLE #TableMax (SourceControlID INT, ExtractTable VARCHAR(100), ExtractJobIDMax INT)

	DECLARE cur CURSOR FOR
	SELECT DISTINCT dc.SourceControlID, dc.ExtractTable, SUBSTRING(ss.ConfiguredValue, 
										CHARINDEX('Initial Catalog', ss.ConfiguredValue) + LEN('Initial CATALOG='), 
										CHARINDEX(';', ss.ConfiguredValue, CHARINDEX('Initial Catalog=', ss.ConfiguredValue))- (CHARINDEX('Initial Catalog=', ss.ConfiguredValue) + LEN('Initial CATALOG=')))
										collate DATABASE_DEFAULT + '.' + [ExtractTable]  AS 'FullExtractTable'
	FROM dbo.DeliveryControl dc
	INNER JOIN [dbo].SourceControl sc ON sc.SourceControlID = dc.SourceControlID
	INNER JOIN [dbo].SSISConfiguration ss ON sc.SSISConfigurationID = ss.SSISConfigurationID
	WHERE ss.ConfiguredValue LIKE '%Initial Catalog=%'

	OPEN cur
	FETCH NEXT FROM cur INTO @SourceControlID, @ExtractTable, @FullExtractTable
	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		SET @sqlQuery = 'INSERT #TableMax SELECT ' + CAST(@SourceControlID AS NVARCHAR(10)) + ', ''' + @ExtractTable + ''', MAX(ExtractJobID) FROM ' + @FullExtractTable
		PRINT @sqlQuery 
		EXEC sp_executesql @sqlQuery
		FETCH NEXT FROM cur INTO @SourceControlID, @ExtractTable, @FullExtractTable
	END
	CLOSE cur;
	DEALLOCATE cur;

------------------------------------------------------------------------------
-- 1.1 Update delivery control
------------------------------------------------------------------------------
	UPDATE [dbo].[DeliveryControl]
	SET [CurrentExtractJobID] = tm.ExtractJobIDMax 
	FROM [dbo].[DeliveryControl] dc
	INNER JOIN #TableMax tm ON dc.[ExtractTable] = tm.ExtractTable AND tm.SourceControlID = dc.SourceControlID
	WHERE ISNULL(dc.CurrentExtractJobID, -1) < tm.ExtractJobIDMax

	DROP TABLE #TableMax

------------------------------------------------------------------------------
-- 2.0 Return if there are any changes requiring Delivery manager to process.
------------------------------------------------------------------------------
	SELECT ISNULL(MAX(ABS([LastExtractJobID] - [CurrentExtractJobID])), 0) AS 'ChangesFound' FROM [dbo].[DeliveryControl] WHERE ISNULL(LastExtractJobID, -1) <> ISNULL(CurrentExtractJobID, -1)
END
GO
PRINT N'Creating [dbo].[spRefreshSSISConfiguration]...';


GO
-- =============================================
-- Author:		Olof Szymczak
-- Create date: 2012-06-20
-- Description:	Refresh SSISConfiguration when a restore has occured
-- =============================================
CREATE PROCEDURE [dbo].[spRefreshSSISConfiguration]
AS
BEGIN

IF  EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_SourceControl_SSISConfiguration]') AND parent_object_id = OBJECT_ID(N'[dbo].[SourceControl]'))
	ALTER TABLE [dbo].[SourceControl] DROP CONSTRAINT [FK_SourceControl_SSISConfiguration]


DELETE FROM [dbo].[SSISConfiguration]
SET IDENTITY_INSERT [dbo].[SSISConfiguration] ON

INSERT INTO dbo.SSISConfiguration ([SSISConfigurationID]
      ,[ConfigurationFilter]
      ,[ConfiguredValue]
      ,[PackagePath]
      ,[ConfiguredValueType]
      ,[Description]
)
SELECT [SSISConfigurationID]
      ,[ConfigurationFilter]
      ,[ConfiguredValue]
      ,[PackagePath]
      ,[ConfiguredValueType]
      ,[Description]
FROM dbo.SSISConfigurationSource

SET IDENTITY_INSERT [dbo].[SSISConfiguration] OFF

ALTER TABLE [dbo].[SourceControl]  WITH CHECK ADD  CONSTRAINT [FK_SourceControl_SSISConfiguration] FOREIGN KEY([SSISConfigurationID])
REFERENCES [dbo].[SSISConfiguration] ([SSISConfigurationID])

ALTER TABLE [dbo].[SourceControl] CHECK CONSTRAINT [FK_SourceControl_SSISConfiguration]

END
GO
PRINT N'Creating [dbo].[spGetSSISPackagePath]...';


GO
CREATE PROCEDURE [dbo].[spGetSSISPackagePath] 
	-- Add the parameters for the stored procedure here
	@SSISPackageName varchar(100),
	@FolderName varchar(100) = 'ETL-RegionalReporting'
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @CurrentFolder as varchar(100)
	DECLARE @FolderPath as varchar(500)
	--declare @SSISPackageName varchar(100)
	IF NOT EXISTS (SELECT top 1 Name FROM msdb.dbo.sysssispackages WHERE Name = @SSISPackageName) 
		SELECT ''
	ELSE
	BEGIN
		 SET @CurrentFolder = (SELECT top 1 pf.FolderName FROM msdb.dbo.sysssispackages p
				INNER JOIN 	msdb.dbo.sysssispackagefolders pf ON p.folderid = pf.folderid 
				WHERE p.Name = @SSISPackageName AND pf.foldername=@FolderName)	
		SET @FolderPath = @CurrentFolder + '\' + @SSISPackageName
		SET @CurrentFolder = (SELECT top 1 f2.foldername 
				FROM msdb.dbo.sysssispackagefolders f1 
				INNER JOIN msdb.dbo.sysssispackagefolders f2 ON f1.parentfolderid = f2.folderID
				WHERE f1.foldername = @CurrentFolder)
				
		print @CurrentFolder
		WHILE (@CurrentFolder IS NOT NULL AND @CurrentFolder <> '')
		BEGIN
			SET @FolderPath = @CurrentFolder + '\' + @FolderPath 
			SET @CurrentFolder = (SELECT top 1 f2.foldername 
				FROM msdb.dbo.sysssispackagefolders f1 
				INNER JOIN msdb.dbo.sysssispackagefolders f2 ON f1.parentfolderid = f2.folderID
				WHERE f1.foldername = @CurrentFolder)
		END		
	SET @FolderPath = '\' + @FolderPath
	SELECT @FolderPath
	END
END
GO
PRINT N'Creating [dbo].[spViewLatestLog]...';


GO
CREATE PROCEDURE [dbo].[spViewLatestLog]( @Suite AS varchar(50), @IsSuccess AS int)
AS

/***********************************************************************************************************
 * FUNCTION: To view the ExtractExecutionLog and DeliveryExecutionLog tables based on the Suite and Success Flag
 *           specified in the parameters order by the highest ExtractJobID and DeliveryJobID respectively.                  
 * PARAMETERS:
 *				@Suite varchar(50) Suite Name
 *              @IsSuccess int 1 for the success and 0 for fail, put 2 for all success and fail
 * CREATED BY: Irwan Iswadi
 * CREATED DATE: 27 Oct 2008
 * LAST MODIFIED DATE: 27 Oct 2008
 ***********************************************************************************************************/
DECLARE @ExtractQuery AS varchar(255)
DECLARE @DeliveryQuery AS varchar(255)

DECLARE @Clause AS varchar(25)

IF @IsSuccess < 2 AND @IsSuccess >= 0 
	SET @Clause = ' AND SuccessFlag = ' + CAST(@IsSuccess AS varchar(1))
ELSE
	SET @Clause = ''

SET @ExtractQuery = 'SELECT * FROM(
SELECT *
, RANK() OVER(PARTITION BY ExtractPackageName ORDER BY ExtractJobID DESC) AS rnk
FROM dbo.ExtractExecutionLog WHERE Suite = ''' +  @Suite + '''' + ') ext WHERE rnk = 1' + @Clause

SET @DeliveryQuery = 'SELECT * FROM(
SELECT *
, RANK() OVER(PARTITION BY DeliveryPackageName ORDER BY DeliveryJobID DESC) AS rnk
FROM dbo.DeliveryExecutionLog WHERE Suite = ''' +  @Suite + ''''  + ') ext WHERE rnk = 1' + @Clause

EXECUTE (@ExtractQuery)
EXECUTE (@DeliveryQuery)

RETURN -1
GO
PRINT N'Creating [dbo].[spCheckBuildCube]...';


GO
-- =============================================
-- Author:		Olof Szymczak
-- Create date: 2012-02-17
-- Description:	Check if the cubes need to be built
-- used as a task in the sql job
-- =============================================
CREATE PROCEDURE [dbo].[spCheckBuildCube] 
AS
BEGIN
	DECLARE @DeliveryTime DATETIME 
	DECLARE @CubeTime DATETIME
	DECLARE @SqlJobServer NVARCHAR(100)
	DECLARE @sqlstmt nvarchar(max)  
	DECLARE @IsRunning INT 
	SET @IsRunning =1 
	SELECT @DeliveryTime = MAX(EndTime)
	FROM dbo.DeliveryExecutionLog
	WHERE SuccessFlag = 1 
	SELECT @CubeTime = MAX(EndTime)
	FROM dbo.CubeExecutionLog
	WHERE SuccessFlag = 1
	SELECT @SqlJobServer = [ConfiguredValue]
    FROM [dbo].[SSISConfiguration]
	WHERE [ConfigurationFilter] = 'ServerSqlJob'

    ---- check whether any delivery package ran after the last cube process
	DECLARE @RESULT1 VARCHAR(10) =CASE WHEN ISNULL(@DeliveryTime, '1900-01-01') < ISNULL(@CubeTime , '1900-01-01')
	                              THEN 'NO' ELSE 'YES' END
	
    ----- Check for the cube built windows	
	dECLARE @RESULT2 VARCHAR(10) = CASE WHEN (CAST(getdate() as time) between '05:30:00' and '9:00:30'
		                           or CAST(getdate() as time) between '11:00:00' and '13:00:30')
		                            THEN 'YES'
		                           ELSE 'NO' END
		
	
	IF (@RESULT1 ='YES' AND @RESULT2 ='YES')
	BEGIN
	SET @sqlstmt = 'select @count = count(1) from OPENROWSET(''SQLNCLI'',''server='+@SqlJobServer+';trusted_Connection=yes;'',''SELECT 1 
			          FROM msdb.dbo.sysjobs J 
                      INNER JOIN msdb.dbo.sysjobactivity A ON A.job_id=J.job_id 
                      WHERE J.name=N''''Regional Distribution ETL Cube Process'''' 
                      AND A.run_requested_date IS NOT NULL 
                      AND A.stop_execution_date IS NULL'') '
		
		
		
	       	EXECUTE sp_executesql @sqlstmt, N'@count int OUTPUT', @count = @IsRunning output                      
           -- Execute the cube refresh job if the Regional Distribution ETL Cube Process is not executing currently
			IF @IsRunning = 0 
			BEGIN
				EXEC msdb.dbo.sp_start_job @job_name = 'Regional Distribution ETL Cube Process', @server_name = @SqlJobServer
			END
	END
END
GO
PRINT N'Creating [dbo].[spGetExtractExecutionDestSqlVariables]...';


GO
CREATE PROCEDURE [dbo].[spGetExtractExecutionDestSqlVariables]
	@ExtractControlID INT
AS
BEGIN
	SET NOCOUNT ON;	
SELECT
sscDestination.ConfiguredValue AS 'ConnStr_Destination',
ec.ExtractTable
FROM dbo.ExtractControl ec 
INNER JOIN dbo.Suite s ON ec.SuiteID = s.SuiteID
INNER JOIN dbo.SourceControl scSource ON ec.SourceControlID = scSource.SourceControlID
INNER JOIN dbo.SSISConfiguration sscSource ON sscSource.SSISConfigurationID = scSource.SSISConfigurationID
INNER JOIN dbo.SourceControl scDestination ON ec.DestinationControlID = scDestination.SourceControlID
INNER JOIN dbo.SSISConfiguration sscDestination ON sscDestination.SSISConfigurationID = scDestination.SSISConfigurationID
WHERE ec.ExtractControlID = @ExtractControlID
END
GO
PRINT N'Creating [dbo].[spGetExtractExecutionSourceFileVariables]...';


GO
CREATE PROCEDURE [dbo].[spGetExtractExecutionSourceFileVariables]
	@ExtractControlID INT
AS
BEGIN
	SET NOCOUNT ON;
	
SELECT
sscSource.ConfiguredValue AS 'FileSource'
FROM dbo.ExtractControl ec 
INNER JOIN dbo.Suite s ON ec.SuiteID = s.SuiteID
INNER JOIN dbo.SourceControl scSource ON ec.SourceControlID = scSource.SourceControlID
INNER JOIN dbo.SSISConfiguration sscSource ON sscSource.SSISConfigurationID = scSource.SSISConfigurationID
WHERE ec.ExtractControlID = @ExtractControlID
END
GO
PRINT N'Creating [dbo].[spGetExtractExecutionSourceSqlVariables]...';


GO


CREATE PROCEDURE [dbo].[spGetExtractExecutionSourceSqlVariables]
	@ExtractControlID INT
AS
BEGIN
	SET NOCOUNT ON;
	
SELECT
sscSource.ConfiguredValue AS 'ConnStr_Source'
FROM dbo.ExtractControl ec 
INNER JOIN dbo.Suite s ON ec.SuiteID = s.SuiteID
INNER JOIN dbo.SourceControl scSource ON ec.SourceControlID = scSource.SourceControlID
INNER JOIN dbo.SSISConfiguration sscSource ON sscSource.SSISConfigurationID = scSource.SSISConfigurationID
WHERE ec.ExtractControlID = @ExtractControlID
END
GO
PRINT N'Creating [dbo].[spGetExtractExecutionDestFileVariables]...';


GO


CREATE PROCEDURE [dbo].[spGetExtractExecutionDestFileVariables]
		@ExtractControlID INT
AS
BEGIN
	SET NOCOUNT ON;
	
SELECT
sscDestination.ConfiguredValue AS 'FileDestination',
ec.ExtractTable AS 'FileName'
FROM dbo.ExtractControl ec 
INNER JOIN dbo.Suite s ON ec.SuiteID = s.SuiteID
INNER JOIN dbo.SourceControl scSource ON ec.SourceControlID = scSource.SourceControlID
INNER JOIN dbo.SSISConfiguration sscSource ON sscSource.SSISConfigurationID = scSource.SSISConfigurationID
INNER JOIN dbo.SourceControl scDestination ON ec.DestinationControlID = scDestination.SourceControlID
INNER JOIN dbo.SSISConfiguration sscDestination ON sscDestination.SSISConfigurationID = scDestination.SSISConfigurationID
WHERE ec.ExtractControlID = @ExtractControlID
END
GO
PRINT N'Creating [dbo].[LongPrintN]...';


GO




CREATE PROCEDURE [dbo].[LongPrintN]( @string nvarchar(max) )
AS
SET NOCOUNT ON

set @string = rtrim( @string )

declare @cr char(1), @lf char(1) 
set @cr = char(13)
set @lf = char(10)

declare @len int, @cr_index int, @lf_index int, @crlf_index int, @has_cr_and_lf bit, @left nvarchar(4000), @reverse nvarchar(4000)
set @len = 4000

while ( len( @string ) > @len )
begin
   set @left = left( @string, @len )
   set @reverse = reverse( @left )
   set @cr_index = @len - charindex( @cr, @reverse ) + 1
   set @lf_index = @len - charindex( @lf, @reverse ) + 1
   set @crlf_index = case when @cr_index < @lf_index then @cr_index else @lf_index end
   set @has_cr_and_lf = case when @cr_index < @len and @lf_index < @len then 1 else 0 end
   print left( @string, @crlf_index - 1 )
   set @string = right( @string, len( @string ) - @crlf_index - @has_cr_and_lf )
end

print @string
GO
PRINT N'Creating [dbo].[spGetDtexecLocation]...';


GO
-- =============================================
-- Author:		Olof Szymczak
-- Create date: 2014/05/09
-- Description:	get location of dtexec
-- =============================================
CREATE PROCEDURE [dbo].[spGetDtexecLocation]
@RunAs32Bit BIT 
AS
BEGIN
	SET NOCOUNT ON;
	IF (@RunAs32Bit = 0)
	BEGIN
		SELECT ConfiguredValue AS 'LocationDtexec' FROM [dbo].[SSISConfiguration] WHERE [ConfigurationFilter] = 'Location_DTEXEC_64Bit'
	END
	ELSE
	BEGIN
		SELECT ConfiguredValue AS 'LocationDtexec' FROM [dbo].[SSISConfiguration] WHERE [ConfigurationFilter] = 'Location_DTEXEC_32Bit'
	END
END
GO
PRINT N'Creating [dbo].[spGetStagingExecutionBulkFileVariables]...';


GO
CREATE PROCEDURE [dbo].[spGetStagingExecutionBulkFileVariables]
	@StagingControlID INT
AS
BEGIN
	SET NOCOUNT ON;
-------------------------------------------------------------------------------
-- Retrieve values
-------------------------------------------------------------------------------
SELECT 
sconp.[ConfiguredValue] AS 'FolderBaseLocation',
scons.[ConfiguredValue] AS 'ConnStr_Staging',
sc.HasFooter,
sc.HasHeader,
sc.DelimiterChar,
COALESCE(scFNS.ConfiguredValue, '') AS 'FileNameSeparator',
COALESCE(scFts.ConfiguredValue, '') AS 'FileTimeStampFormat'
FROM dbo.StagingControl sc 
INNER JOIN dbo.SourceControl scp ON sc.SourceControlID = scp.SourceControlID
INNER JOIN dbo.SSISConfiguration sconp ON sconp.[SSISConfigurationID] = scp.SSISConfigurationID
INNER JOIN dbo.SourceControl scs ON sc.StagingDestControlID = scs.SourceControlID
INNER JOIN dbo.SSISConfiguration scons ON scons.[SSISConfigurationID] = scs.SSISConfigurationID
INNER JOIN dbo.SSISConfiguration scFNS ON scFNS.ConfigurationFilter = 'FileNameSeparator'
INNER JOIN dbo.SSISConfiguration scFts ON scFts.ConfigurationFilter = 'FileTimeStampFormat'
WHERE sc.ProcessType = 'BULKFILE'
AND sc.StagingControlID = @StagingControlID
END
GO
PRINT N'Creating [dbo].[spGetStagingManagerFolderLocation]...';


GO



-------------------------------------------------------------------------------
-- Author:	oszymczak
-- Create date: 2014/03/28
-- Description:	Folder Location for a suite
-------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[spGetStagingManagerFolderLocation]
@SuiteName NVARCHAR(50) 
AS
BEGIN
SET NOCOUNT ON

SELECT DISTINCT sspc.ConfiguredValue AS 'BaseFolder', ssEnv.ConfiguredValue AS 'Environment', s.SuiteName,  'Unprocessed' AS 'Folder' FROM dbo.StagingControl sc
INNER JOIN dbo.SourceControl spc ON spc.SourceControlID = sc.SourceControlID
INNER JOIN dbo.SSISConfiguration sspc ON sspc.SSISConfigurationID = spc.SSISConfigurationID
INNER JOIN dbo.SSISConfiguration ssEnv ON ssEnv.ConfigurationFilter = 'Environment'
INNER JOIN dbo.Suite s ON sc.SuiteID = s.SuiteID
WHERE s.Status = 'S'
AND sc.Status = 'S'
AND sc.ProcessType = 'BULKFILE'
AND s.SuiteName = @SuiteName
END
GO
PRINT N'Creating [dbo].[spGetStagingManagerVariables]...';


GO


-------------------------------------------------------------------------------
-- Author:	oszymczak
-- Create date: 2014/03/28
-- Description:	Returns Staging Manager Variables
-------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[spGetStagingManagerVariables]
AS
BEGIN
SET NOCOUNT ON

SELECT scSrv.ConfiguredValue AS  'Server',
dbo.udfPackagePathName(scEnv.ConfiguredValue, SUBSTRING(scDel.ConfiguredValue, 0, CHARINDEX('\', scDel.ConfiguredValue, 2)), SUBSTRING(scDel.ConfiguredValue, CHARINDEX('\', scDel.ConfiguredValue, 2) + 1, LEN(scDel.ConfiguredValue) - CHARINDEX('\', scDel.ConfiguredValue, 2))) AS 'StagingExecutionLocation',
scMSDB.ConfiguredValue AS 'ConnStr_msdb',
scFS.ConfiguredValue AS 'FileNameSeparator'
FROM dbo.SSISConfiguration scEnv
INNER JOIN dbo.SSISConfiguration scSrv ON scSrv.ConfigurationFilter = 'Server'
INNER JOIN dbo.SSISConfiguration scDel ON scDel.ConfigurationFilter = 'StagingExecutionLocation'
INNER JOIN dbo.SSISConfiguration scMSDB ON scMSDB.ConfigurationFilter = 'ConnStr_msdb'
INNER JOIN dbo.SSISConfiguration scFS ON scFS.ConfigurationFilter = 'FileNameSeparator'
WHERE scEnv.ConfigurationFilter = 'Environment'
END
GO
PRINT N'Creating [dbo].[spGetStagingPackagesFile]...';


GO

CREATE PROCEDURE [dbo].[spGetStagingPackagesFile]
	@SuiteName VARCHAR(50),
	@Packages varchar(max)
AS
BEGIN
	SET NOCOUNT ON;
   
   DECLARE @sql varchar(max)
   SET @sql =' SELECT DISTINCT StagingControlID, StagingPackageName '+
		' FROM dbo.StagingControl sc'+
        ' INNER JOIN dbo.Suite s ON sc.SuiteID = s.SuiteID'+
        ' WHERE s.SuiteName = '''+@SuiteName +''''+
            ' AND sc.StagingPackageName IN ('+@Packages+')'+
            ' AND s.Status = ''S'' '+  
            ' AND sc.Status = ''S'' '+
			' AND sc.ProcessType = ''BULKFILE''';


	EXEC sys.sp_sqlexec @sql
END
GO
PRINT N'Creating [dbo].[spGetStagingSuites]...';


GO


-- =============================================
-- Author:	oszymczak
-- Create date: 25/03/2014
-- Description:	Get StagingControl Suites
-- =============================================
CREATE PROCEDURE [dbo].[spGetStagingSuites]
AS
BEGIN
	SET NOCOUNT ON;

	SET NOCOUNT ON;
	DECLARE @ErrorMessage NVARCHAR(1000)

	IF EXISTS(	SELECT DISTINCT 1
	FROM dbo.Suite s (NOLOCK)
	INNER JOIN dbo.StagingControl sc (NOLOCK) ON s.SuiteID = sc.SuiteID
	WHERE sc.Status IS NULL OR sc.Status IS NULL
	)
	BEGIN

		SET @ErrorMessage = 'GetStagingSuites|Suite has not been correctly setup it is missing.'
		RAISERROR(@ErrorMessage, 16, 1);
	END


	SELECT DISTINCT s.SuiteName AS 'Suite'
	FROM dbo.Suite s (NOLOCK)
	INNER JOIN dbo.StagingControl sc (NOLOCK) ON s.SuiteID = sc.SuiteID
	LEFT JOIN dbo.SourceControl SourceSC (NOLOCK) ON sc.SourceControlID = SourceSC.SourceControlID
	LEFT JOIN dbo.SSISConfiguration SourceSSC (NOLOCK) ON SourceSC.SSISConfigurationID = SourceSSC.SSISConfigurationID
	WHERE s.Status = 'S'
	AND sc.Status = 'S'
	AND ((ProcessType = 'BULKFILE') OR (ProcessType = 'BULKSQL' AND NextRunDateTime <= GETDATE()))
	ORDER BY s.SuiteName
END
GO
PRINT N'Creating [dbo].[udpLongPrintN]...';


GO
CREATE PROCEDURE [dbo].[udpLongPrintN]( @string nvarchar(max) )
AS
SET NOCOUNT ON

set @string = rtrim( @string )

declare @cr char(1), @lf char(1) 
set @cr = char(13)
set @lf = char(10)

declare @len int, @cr_index int, @lf_index int, @crlf_index int, @has_cr_and_lf bit, @left nvarchar(4000), @reverse nvarchar(4000)
set @len = 4000

while ( len( @string ) > @len )
begin
   set @left = left( @string, @len )
   set @reverse = reverse( @left )
   set @cr_index = @len - charindex( @cr, @reverse ) + 1
   set @lf_index = @len - charindex( @lf, @reverse ) + 1
   set @crlf_index = case when @cr_index < @lf_index then @cr_index else @lf_index end
   set @has_cr_and_lf = case when @cr_index < @len and @lf_index < @len then 1 else 0 end
   print left( @string, @crlf_index - 1 )
   set @string = right( @string, len( @string ) - @crlf_index - @has_cr_and_lf )
end

print @string
GO
PRINT N'Creating [dbo].[sp_SendEmailFailedLogToday]...';


GO

/**************************************************************************************************************

Author		:	Preethi Khatore
Create date	:	2 Nov 2009
Description	:	To send the failed process summary message 

Altered		:	Dylan Harvey
Date		:	20120912
Description	:	Removed logic for 'WithOutCubeBuilt' and call new stored proc



**************************************************************************************************************/
CREATE  PROCEDURE [dbo].[sp_SendEmailFailedLogToday] 
	-- Add the parameters for the stored procedure here
	@RecipientEmail varchar(max) = 0,
	@SystemName varchar(max) = 0,
	@CubeBuiltStatus varchar(50) ='WithOutCubeBuilt'
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
  -- DECLARE	@RecipientEmail varchar(max) = 'Preethi.khatore@brightstarcorp.com'
	--DECLARE @SystemName varchar(max) = 'UAT Regional Distribution'
    
    DECLARE @SuccessMessage AS VARCHAR(MAX)
    DECLARE @LogQuery AS VARCHAR(MAX)
    DECLARE @BodyMessage AS VARCHAR(MAX)
    DECLARE @Importance AS VARCHAR(20)
    DECLARE @CubeBuiltcompletestatus AS VARCHAR(50) = @CubeBuiltStatus
    declare @count int
    
    DECLARE @ProfileName NVARCHAR(255)
	SELECT @ProfileName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'EmailProfileName'
    
     If @CubeBuiltcompletestatus='WithCubeBuiltCompleted'
    BEGIN
    SELECT @SuccessMessage = 
				CASE 
					WHEN COUNT(*) = 0 
					THEN @SystemName + ' Process Log Summary - No Error Found' 
					ELSE 'FAILURE '+@SystemName + ' Process Log Summary!' END,
		   @Importance =
				CASE 
					WHEN COUNT(*) > 0 
					THEN 'High' 
					ELSE 'Normal' END,
		   @BodyMessage	= 'Hi'+ CHAR(10) + CHAR(10) +
				'Please do not reply this email as it is auto generated from ' + @SystemName + ' system. If you have any questions with this email please contact ' + @SystemName + ' team.' + CHAR(10) + CHAR(10) +
				CASE
					WHEN COUNT(*) = 0 
					THEN 'Please ignore the attachment as there is no error found.'
					ELSE  'Please check the attachment file as there are errors found in ' + 	@SystemName
				END + CHAR(10) + CHAR(10)
    FROM vi_FailedLogToday
    
    SET @LogQuery =  'SET NOCOUNT ON; SELECT * FROM RegDistETLReference.dbo.vi_FailedLogToday'
    
   -- select @count=COUNT(*) from vi_FailedLogToday
    
     EXEC msdb.dbo.sp_send_dbmail
    @profile_name = @ProfileName,
    @recipients = @RecipientEmail,
    @body = @BodyMessage,
    @query = @LogQuery ,
    @subject =@SuccessMessage,
    @Importance = @Importance,
    @attach_query_result_as_file = 1,
    @query_result_no_padding = 0

END
ELSE IF @CubeBuiltcompletestatus='WithOutCubeBuilt'
	----If @CubeBuiltcompletestatus='WithOutCubeBuilt'



	 --DH 20120912 Replaced with new stored proc

	 BEGIN
	   SELECT @SuccessMessage = 
				CASE 
					WHEN COUNT(*) = 0 
					THEN @SystemName + ' Process Log Summary - No Error Found' 
					ELSE 'FAILURE '+@SystemName + ' Process Log Summary!' END,
		   @Importance =
				CASE 
					WHEN COUNT(*) > 0 
					THEN 'High' 
					ELSE 'Normal' END,
		   @BodyMessage	= 'Hi'+ CHAR(10) + CHAR(10) +
				'Please do not reply this email as it is auto generated from ' + @SystemName + ' system. If you have any questions with this email please contact ' + @SystemName + ' team.' + CHAR(10) + CHAR(10) +
				CASE
					WHEN COUNT(*) = 0 
					THEN 'Please ignore the attachment as there is no error found.'
					ELSE  'Please check the attachment file as there are errors found in ' + 	@SystemName
				END + CHAR(10) + CHAR(10)
	   FROM vi_FailedLogToday_Extractonly

	   SET @LogQuery =  'SET NOCOUNT ON; SELECT * FROM RegDistETLReference.dbo.vi_FailedLogToday_Extractonly'

	    select @count=COUNT(*)
	     from vi_FailedLogToday_Extractonly

	    --- Only if any error records exist
	    if @count>0


	   EXEC msdb.dbo.sp_send_dbmail
	   @profile_name = @ProfileName,
	   @recipients = @RecipientEmail,
	   @body = @BodyMessage,
	   @query = @LogQuery ,
	   @subject =@SuccessMessage,
	   @Importance = @Importance,
	   @attach_query_result_as_file = 1,
	   @query_result_no_padding = 0


	END
 ELSE 
	BEGIN 
	EXEC [spSendEmailExtractFailure] @RecipientEmail,	@SystemName ,'Now'
	END
END
GO
PRINT N'Creating [dbo].[sp_SendEmailPreprocessLog]...';


GO
-- =============================================
-- Author:		Irwan Iswadi
-- Create date: 1 Jul 2009
-- Description:	To send the Preprocess log summary email notification
-- =============================================
CREATE PROCEDURE [dbo].[sp_SendEmailPreprocessLog] 
	-- Add the parameters for the stored procedure here
	@RecipientEmail varchar(max) = 0, 
	@PreprocessJobID int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here

    DECLARE @SuccessMessage AS VARCHAR(MAX)
    DECLARE @LogQuery AS VARCHAR(MAX)
    DECLARE @Importance AS VARCHAR(20)

    SELECT @SuccessMessage = 
				CASE 
					WHEN MIN(SuccessFlag) = 'N' 
					THEN 'PLM NZ Preprocess Failed' 
					ELSE 'PLM NZ PreProcess Success' END,
		   @Importance =
				CASE 
					WHEN MIN(SuccessFlag) = 'N' 
					THEN 'High' 
					ELSE 'Normal' END
    FROM vi_PreprocessLog_Summary
    WHERE PreProcessJobID = @PreprocessJobID

    SET @LogQuery =  'SELECT PreprocessJobID, 
		''The '' + SourceFileName + '' from the '' + CompressedFileName + '' has '' +  CASE WHEN SuccessFlag = 1 THEN ''valid records'' ELSE ''invalid records'' END + '';'' + Message FROM dbo.PreProcessExecutionLog WHERE PreProcessJobID = ' + CAST(@PreprocessJobID as varchar(15)) 



    EXEC msdb.dbo.sp_send_dbmail
    @profile_name = 'SQL Admin',
    @recipients = @RecipientEmail,
    @query = @LogQuery ,
    @subject = @SuccessMessage,
    @Importance = @Importance,
    @attach_query_result_as_file = 0,
    @query_result_no_padding = 1

END
GO
PRINT N'Creating [dbo].[sp_SendEmailSummaryFailedToday]...';


GO

-- ==================================================================
-- Author:		Preethi Khatore
-- Create date: 01 Feb 2012
-- Description:	To send the Summary failed process summary message 
-- ===================================================================
CREATE PROCEDURE [dbo].[sp_SendEmailSummaryFailedToday] 
	-- Add the parameters for the stored procedure here
	@RecipientEmail varchar(max) = 0,
	@SystemName varchar(max) = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
   --DECLARE	@RecipientEmail varchar(max) = 'Preethi.khatore@brightstarcorp.com'
	--DECLARE @SystemName varchar(max) = 'UAT Regional Distribution'
    
    DECLARE @SuccessMessage AS VARCHAR(MAX)
    DECLARE @LogQuery AS VARCHAR(MAX)
    DECLARE @BodyMessage AS VARCHAR(MAX)
    DECLARE @Importance AS VARCHAR(20)
    DECLARE @count int =1
    DECLARE @Currentcnt int =1
    
    while @count=@Currentcnt 
    BEGIN
    
    
    SELECT @SuccessMessage = 'Regional Distribution Summary Load Failed',			
		   @Importance = 'High',
		   @BodyMessage	= 'Hi'+ CHAR(10) + CHAR(10) +
				'Please do not reply this email as it is auto generated from ' + @SystemName + ' system. If you have any questions with this email please contact ' + @SystemName + ' team.' + CHAR(10) + CHAR(10) +
				 'Check the Summary load step in ' + 	@SystemName
				 + CHAR(10) + CHAR(10)
    
   -- SET @LogQuery =  'SET NOCOUNT ON; SELECT * FROM RegDistETLReference.dbo.vi_FailedLogToday'
    
    DECLARE @ProfileName NVARCHAR(255)
	SELECT @ProfileName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'EmailProfileName'
	
	EXEC msdb.dbo.sp_send_dbmail
    @profile_name = @ProfileName,
    @recipients = @RecipientEmail,
    @body = @BodyMessage,
   -- @query = @LogQuery ,
    @subject =@SuccessMessage,
    @Importance = @Importance,
    --@attach_query_result_as_file = 1,
    @query_result_no_padding = 0
    
    SET @Currentcnt=@Currentcnt+1
    END

END
GO
PRINT N'Creating [dbo].[spGetNextTime]...';


GO


CREATE PROC [dbo].[spGetNextTime]
@CurrentDateTime DATETIME,
@ScheduleID INT,
@NextRunDateTime DATETIME OUTPUT
AS
BEGIN
 	DECLARE @Mon BIT
	DECLARE @Tue BIT
	DECLARE @Wed BIT
	DECLARE @Thu BIT
	DECLARE @Fri BIT
	DECLARE @Sat BIT
	DECLARE @Sun BIT
	DECLARE @StartTime TIME(0)
	DECLARE @EndTime TIME(0)
	DECLARE @OccursEvery TIME(0)
	DECLARE @NextDateTime DATETIME = @CurrentDateTime
	DECLARE @NextTime TIME(0) = @CurrentDateTime
	DECLARE @TimeSet BIT = 0
	DECLARE @Loop BIT = 0
	DECLARE @days int
	DECLARE @TodayName VARCHAR(3)
	DECLARE @ScheduleTypeId INT
	DECLARE @ErrorMessage VARCHAR(1000)  

	SELECT @Mon = Mon,
	@Tue = Tue,
	@Wed = Wed,
	@Thu = Thu,
	@Fri = Fri,
	@Sat = Sat,
	@Sun = Sun,
	@StartTime = StartTime,
	@EndTime = EndTime,
	@OccursEvery = OccursEvery,
	@ScheduleTypeId = ScheduleTypeId
	FROM dbo.Schedule WHERE ScheduleID = @ScheduleID
-------------------------------------------------------------------------------
-- Error handling
-------------------------------------------------------------------------------
	IF (@Mon IS NULL AND
	@Tue IS NULL AND
	@Wed IS NULL AND
	@Thu IS NULL AND
	@Fri IS NULL AND
	@Sat IS NULL AND
	@Sun IS NULL)
	BEGIN
		SET @ErrorMessage = 'Schedule|day of the week has not been selected for.' + CAST(@ScheduleID AS VARCHAR(30));
		RAISERROR(@ErrorMessage, 16, 1);
	END
    
	IF @StartTime IS NULL
	BEGIN
		SET @ErrorMessage = 'Schedule|No start time has been specified.' + CAST(@ScheduleID AS VARCHAR(30))  
		RAISERROR(@ErrorMessage, 16, 1);
	END  

	IF @StartTime IS NOT NULL AND @EndTime  IS NOT NULL AND @OccursEvery IS NULL
	BEGIN
		SET @ErrorMessage = 'Schedule|OccursEvery has not been specified.' + CAST(@ScheduleID AS VARCHAR(30))  
		RAISERROR(@ErrorMessage, 16, 1);
	END  

-------------------------------------------------------------------------------
-- Calculate
-------------------------------------------------------------------------------
	IF @ScheduleTypeId = -1
	BEGIN
		SET @NextDateTime = '9999-12-31' -- Never to run again
	END
	ELSE IF @ScheduleTypeId = 1
	BEGIN
		SET @NextDateTime = CONVERT(DATETIME, (CONVERT(VARCHAR(10), @NextDateTime, 111) + ' ' + CONVERT(VARCHAR(30), @StartTime)))
		WHILE @Loop = 0
		BEGIN
			SET @TodayName = SUBSTRING(DATENAME(dw, @NextDateTime), 1 ,3)
			
			IF (@TodayName = 'Mon' AND @Mon = 1)
			   OR (@TodayName = 'Tue' AND @Tue = 1)
			   OR (@TodayName = 'Wed' AND @Wed = 1)
			   OR (@TodayName = 'Thu' AND @Thu = 1)
			   OR (@TodayName = 'Fri' AND @Fri = 1)
			   OR (@TodayName = 'Sat' AND @Sat = 1)
			   OR (@TodayName = 'Sun' AND @Sun = 1)
			BEGIN
				IF @CurrentDateTime <= @NextDateTime 
				BEGIN
					BREAK			
				END
			END
			
			IF( @EndTime IS NOT NULL AND @OccursEvery IS NOT NULL AND @TimeSet = 0)
			BEGIN
			    IF (DATEDIFF(SECOND,@StartTime, @NextTime) < 0)
			    BEGIN
					SET @NextDateTime = CONVERT(DATETIME, (CONVERT(VARCHAR(10), @NextDateTime, 111) + ' ' + CONVERT(VARCHAR(30), @StartTime)))			    
			    END
			    ELSE IF @NextTime BETWEEN @StartTime AND @EndTime
			    BEGIN
					SET @NextTime = DATEADD(SECOND,(DATEDIFF(SECOND,@StartTime, @NextTime)/ DATEDIFF(SECOND,0, @OccursEvery) + 1) * DATEDIFF(SECOND,0, @OccursEvery), @StartTime)
					SET @NextDateTime = CONVERT(DATETIME, (CONVERT(VARCHAR(10), @NextDateTime, 111) + ' ' + CONVERT(VARCHAR(30), @NextTime)))
				END
				
				IF (DATEDIFF(SECOND,@NextTime, @EndTime) < 0)
				BEGIN
					SET @NextDateTime = DATEADD(d,1,@NextDateTime)
					SET @NextDateTime = CONVERT(DATETIME, (CONVERT(VARCHAR(10), @NextDateTime, 111) + ' ' + CONVERT(VARCHAR(30), @StartTime)))
				END
				
				SET @TimeSet = 1
			END
			ELSE
			BEGIN
				SET @NextDateTime = DATEADD(d,1,@NextDateTime)
			END
		END
	END

    SET @NextRunDateTime = @NextDateTime
END
GO
PRINT N'Creating [dbo].[spSendEmailDeliveryFailure]...';


GO

-- =============================================
-- Author:		Olof Szymczak
-- Create date: 16/12/2013
-- Description:	To send failed delivery message 
-- =============================================
CREATE PROCEDURE [dbo].[spSendEmailDeliveryFailure]
  @EmailReceipent varchar(max) = 0,
  @LastErrorEmailChecker DATETIME,
  @ScheduleType NVARCHAR(100)
AS
BEGIN
	SET NOCOUNT ON;
    
	DECLARE @Message AS VARCHAR(MAX)
	DECLARE @LogQuery AS VARCHAR(MAX)
	DECLARE @BodyMessage AS VARCHAR(MAX)
	DECLARE @Importance AS VARCHAR(20)
	DECLARE @count int    
	DECLARE @ProfileName NVARCHAR(255)
	DECLARE @SystemName varchar(max)
	DECLARE @tableHTML  NVARCHAR(MAX) 
    DECLARE @Email_Subject NVARCHAR(255)
    
    
    -- Set variables
	SELECT @ProfileName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'EmailProfileName'
	SELECT @SystemName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'SystemName'
	SELECT @Email_Subject = '!!!Failure!!! - ' + @SystemName + ' Delivery Process Failed'
	SELECT @Importance = 'High'

	--Check if a process has failed and no action has been taken
	SELECT @count = COUNT (*)
	FROM [DeliveryControl] dc (NOLOCK)
	INNER JOIN  dbo.DeliveryExecutionlog dcl(nolock) ON dc.DeliveryControlID = dcl.DeliveryControlID
	WHERE  dcl.successflag =0 
	AND @LastErrorEmailChecker <= EndTime
	IF @count > 0
	BEGIN 
			SET @tableHTML =
			N'<H1>'+@SystemName+' Process Failure</H1>' +
			N'<font size = "3">Hi,<br>' + CHAR(10) + CHAR(10) +
			N'<br>Please check DWReference.' + CHAR(10) + CHAR(10) +
			N'<br>Please do not reply this email as it is auto generated from ' + @SystemName + 
			' system. If you have any questions with this email please contact ' + @SystemName + ' team.</font>'+
			N'<table border="1">' +
			N'<tr><th>DeliveryControlID</th>'+    
			N'<th>DeliveryPackageName</th>' +
			N'<th>Package failed date time</th>'+
			CAST ( ( 
			SELECT '#FF0000' AS [@bgcolor],
			td = DeliveryControlID, '',
			td = DeliveryPackageName, '',
			td = EndTime , ''
			FROM (	
					SELECT dc.DeliveryControlID, dc.DeliveryPackageName, MAX(EndTime) AS 'EndTime'
					FROM [DeliveryControl] dc (NOLOCK)
					INNER JOIN  dbo.DeliveryExecutionlog dcl(nolock) ON dc.DeliveryControlID = dcl.DeliveryControlID
					WHERE  dcl.successflag =0 
					AND @LastErrorEmailChecker <= EndTime
					GROUP BY dc.DeliveryControlID, dc.DeliveryPackageName
				)a
					FOR XML PATH('tr'), TYPE 
			) AS NVARCHAR(MAX) ) +
			N'</table>
<br>Legend
<table border="1">
	<tr>
		<th>Colour</th>  
		<th>Description</th>
	</tr>
	<tr><td bgcolor="#FF0000"></td><td>The package has failed and will not work until an administrator resets the status</td></tr>
	<tr><td bgcolor="#F7FE2E"></td><td>This is a warning that the package has failed but will continue to work until it hits the max fail count</td></tr>
</table>'

			EXEC	msdb.dbo.sp_send_dbmail
			@profile_name = @ProfileName,
			@recipients = @EmailReceipent,
			@body = @tableHTML,					
			@body_format = 'HTML', 
			@query = @LogQuery ,
			@subject =@Email_Subject,
			@Importance = @Importance
					
		END 			    
END
GO
PRINT N'Creating [dbo].[spSendEmailSummaryFailure]...';


GO


-- =============================================
-- Author:		Olof Szymczak
-- Create date: 16/12/2013
-- Description:	To send failed summary message 
-- =============================================
CREATE PROCEDURE [dbo].[spSendEmailSummaryFailure]
  @EmailReceipent varchar(max) = 0,
  @LastErrorEmailChecker DATETIME,
  @ScheduleType NVARCHAR(100)
AS
BEGIN
	SET NOCOUNT ON;
    
	DECLARE @Message AS VARCHAR(MAX)
	DECLARE @LogQuery AS VARCHAR(MAX)
	DECLARE @BodyMessage AS VARCHAR(MAX)
	DECLARE @Importance AS VARCHAR(20)
	DECLARE @count int    
	DECLARE @ProfileName NVARCHAR(255)
	DECLARE @SystemName varchar(max)
	DECLARE @tableHTML  NVARCHAR(MAX) 
    DECLARE @Email_Subject NVARCHAR(255)
    
    
    -- Set variables
	SELECT @ProfileName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'EmailProfileName'
	SELECT @SystemName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'SystemName'
	SELECT @Email_Subject = '!!!Failure!!! - ' + @SystemName + ' Summary Process Failed'
	SELECT @Importance = 'High'

	--Check if a process has failed and no action has been taken
	SELECT @count = COUNT (*)
	FROM [SummaryControl] sc (NOLOCK)
	INNER JOIN  dbo.SummaryExecutionlog scl(nolock) ON sc.SummaryControlID = scl.SummaryControlID
	WHERE  scl.successflag =0 
	AND @LastErrorEmailChecker <= scl.EndTime
	IF @count > 0
	BEGIN 
			SET @tableHTML =
			N'<H1>'+@SystemName+' Process Failure</H1>' +
			N'<font size = "3">Hi,<br>' + CHAR(10) + CHAR(10) +
			N'<br>Please check DWReference.' + CHAR(10) + CHAR(10) +
			N'<br>Please do not reply this email as it is auto generated from ' + @SystemName + 
			' system. If you have any questions with this email please contact ' + @SystemName + ' team.</font>'+
			N'<table border="1">' +
			N'<tr><th>SummaryControlID</th>'+    
			N'<th>SummaryPackageName</th>' +
			N'<th>Package failed date time</th>'+
			CAST ( ( 
			SELECT '#FF0000' AS [@bgcolor],
			td = SummaryControlID, '',
			td = SummaryPackageName, '',
			td = EndTime, ''
			FROM (	
					SELECT sc.SummaryControlID, sc.SummaryPackageName, MAX(scl.EndTime) AS 'EndTime'
					FROM [SummaryControl] sc (NOLOCK)
					INNER JOIN  dbo.SummaryExecutionlog scl(nolock) ON sc.SummaryControlID = scl.SummaryControlID
					WHERE  scl.successflag =0 
					AND @LastErrorEmailChecker <= scl.EndTime
					GROUP BY sc.SummaryControlID, sc.SummaryPackageName
				)a
					FOR XML PATH('tr'), TYPE 
			) AS NVARCHAR(MAX) ) +
			N'</table>
<br>Legend
<table border="1">
	<tr>
		<th>Colour</th>  
		<th>Description</th>
	</tr>
	<tr><td bgcolor="#FF0000"></td><td>The package has failed and will not work until an administrator resets the status</td></tr>
	<tr><td bgcolor="#F7FE2E"></td><td>This is a warning that the package has failed but will continue to work until it hits the max fail count</td></tr>
</table>'

			EXEC	msdb.dbo.sp_send_dbmail
			@profile_name = @ProfileName,
			@recipients = @EmailReceipent,
			@body = @tableHTML,					
			@body_format = 'HTML', 
			@query = @LogQuery ,
			@subject =@Email_Subject,
			@Importance = @Importance
					
		END 			    
END
GO
PRINT N'Creating [dbo].[spSendEmailStagingMaxExpectedDurationBetweenFiles]...';


GO

-- =============================================
-- Author:		Nghi Ta
-- Create date: 1/7/2014
-- Description:	To send email notify staging manager has not found any file to execute
-- =============================================
CREATE PROCEDURE [dbo].[spSendEmailStagingMaxExpectedDurationBetweenFiles]
  @EmailReceipent varchar(max) = 0,
  @LastErrorEmailChecker DATETIME
AS
BEGIN
	SET NOCOUNT ON;
    
	DECLARE @Message AS VARCHAR(MAX)
	DECLARE @LogQuery AS VARCHAR(MAX)
	DECLARE @BodyMessage AS VARCHAR(MAX)
	DECLARE @Importance AS VARCHAR(20)
	DECLARE @count int    
	DECLARE @ProfileName NVARCHAR(255)
	DECLARE @SystemName varchar(max)
	DECLARE @tableHTML  NVARCHAR(MAX) 
    DECLARE @Email_Subject NVARCHAR(255)
    
    -- Set variables
	SELECT @ProfileName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'EmailProfileName'
	SELECT @SystemName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'SystemName'
	SELECT @Email_Subject = '!!!Failure!!! - ' + @SystemName + ' Checking Staging Max Expected Duration Between Files Failed'
	SELECT @Importance = 'High'

	--Check if a process has failed and no action has been taken
	
	SELECT @count = COUNT (*)
	FROM dbo.StagingControl 
		WHERE  LastProcessedTime >= @LastErrorEmailChecker
		AND (LastProcessedTime + CONVERT(DATETIME, MaxExpectedDurationBetweenFiles)) < GETDATE()

	IF @count > 0
	BEGIN 
			SET @tableHTML =
			N'<H1>'+@SystemName+' Process Failure</H1>' +
			N'<font size = "3">Hi,<br>' + CHAR(10) + CHAR(10) +
			N'<br>Please check DWReference, the status is reporting that the packages below have failed.<br>  '+
			'This will need to be investigated.' + CHAR(10) + CHAR(10) +
			N'<br>Please do not reply this email as it is auto generated from ' + @SystemName + 
			' system. If you have any questions with this email please contact ' + @SystemName + ' team.</font>'+
			N'<table border="1">' +
			N'<tr><th>Staging Control ID</th>'+    
			N'<th>Suite Name</th>' +
			N'<th>Staging Package Name</th>' +
			N'<th>Status</th>' +
			N'<th>Status Change Date Time</th>' +
			N'<th>Last Processed Time</th>' +
			N'<th>Max Expected Duration Between Files</th>' +
			N'<th>Expected Next Execution Time</th>' +
			CAST ( ( 
			SELECT  '#F7FE2E' AS [@bgcolor],
			td = StagingControlID, '',
			td = SuiteName, '',
			td = StagingPackageName, '',
			td = Status, '',
			td = StatusChangeDateTime, '',
			td = LastProcessedTime, '',
			td = MaxExpectedDurationBetweenFiles, '',
			td = ExpectedNextExecutionTime, ''
			FROM (	
					SELECT sc.StagingControlID, 
							s.SuiteName,
							sc.StagingPackageName,
							sc.Status,
							sc.StatusChangeDateTime,
							sc.LastProcessedTime,
							sc.MaxExpectedDurationBetweenFiles,
							(sc.LastProcessedTime + CONVERT(DATETIME, sc.MaxExpectedDurationBetweenFiles)) AS ExpectedNextExecutionTime
							FROM dbo.StagingControl sc
							INNER JOIN dbo.Suite s
							ON s.SuiteID = sc.SuiteID
							WHERE  sc.LastProcessedTime >= @LastErrorEmailChecker
							AND (LastProcessedTime + CONVERT(DATETIME,MaxExpectedDurationBetweenFiles)) < GETDATE()
				)a
					FOR XML PATH('tr'), TYPE 
			) AS NVARCHAR(MAX) ) +
			N'</table>
<br>Legend
<table border="1">
	<tr>
		<th>Colour</th>  
		<th>Description</th>
	</tr>
	<tr><td bgcolor="#F7FE2E"></td><td>This is a warning that the staging manager cannot execute file on expected time</td></tr>
</table>'

			BEGIN
					EXEC	msdb.dbo.sp_send_dbmail
					@profile_name = @ProfileName,
					@recipients = @EmailReceipent,
					@body = @tableHTML,					
					@body_format = 'HTML', 
					@query = @LogQuery ,
					@subject =@Email_Subject,
					@Importance = @Importance
			END				
			
		END 			    
			
		-- Update max expected execution email sent
		UPDATE [StagingControl] 
		SET [MaxExpectedExecutionEmailSent] = GETDATE()
		WHERE  LastProcessedTime >= @LastErrorEmailChecker
		AND (LastProcessedTime + CONVERT(DATETIME, MaxExpectedDurationBetweenFiles)) < GETDATE()
END
GO
PRINT N'Creating [dbo].[spGetStagingPackagesSql]...';


GO
-- =============================================
-- Author:	oszymczak
-- Create date: 06/05/2014
-- Description:	Get Staging Packages based on Suite 
-- =============================================
CREATE PROCEDURE [dbo].[spGetStagingPackagesSql]
	@SuiteName VARCHAR(50)
AS
BEGIN
	SET NOCOUNT ON;
	
	SELECT DISTINCT sc.StagingControlID
	FROM dbo.StagingControl sc (NOLOCK)
	INNER JOIN dbo.Suite s (NOLOCK) ON sc.SuiteID = s.SuiteID
	WHERE	
	s.SuiteName = @SuiteName
	AND sc.NextRunDateTime <= GETDATE()
	AND sc.Status = 'S'
	AND sc.ProcessType = 'BULKSQL'
END
GO
PRINT N'Creating [dbo].[spSendEmailSummaryMaxJobIDFailure]...';


GO

-- ===============================================================================
-- Author:		Nghi Ta
-- Create date: 26/6/2014
-- Description:	To send the failed for check max job id in logical layer 
-- History:     
--         Modified By               Modified Date           Reason of Changes
--         Nghi Ta                   2014-7-15               Remove hardcode database name
-- ================================================================================
CREATE PROCEDURE [dbo].[spSendEmailSummaryMaxJobIDFailure]
AS
BEGIN
	SET NOCOUNT ON;

DECLARE @schemaName nvarchar(20)=''
DECLARE @tableName nvarchar(100)
DECLARE @ETLDeliveryJobId int
DECLARE @ETLSummaryJobId int
DECLARE @summaryTableHTML  varchar(max)=''

DECLARE @SummaryErrorTable TABLE
(
    ETLParameterSummaryJobId int,
	ETLParameterDeliveryJobId int,
	SummaryControlId int,
	SummaryPackageName varchar(200),
	LastSummaryJobId int,
	LastDeliveryJobId int,
	CurrentDeliveryJobId int
)


-- Get Summary Job Id from ETLParameters
SELECT @ETLSummaryJobId = ETLParameterValue FROM dbo.ETLParameters 
WHERE ETLParameterName =  'SummaryJobID'

-- Get Delivery Job Id from ETLParameters
SELECT @ETLDeliveryJobId = ETLParameterValue FROM dbo.ETLParameters 
WHERE ETLParameterName =  'DeliveryJobID'
DECLARE @count int


SELECT @count = count(*) FROM dbo.SummaryControl sc 
	WHERE LastSummaryJobID > @ETLSummaryJobId 
		OR LastDeliveryJobID > @ETLDeliveryJobId
		OR CurrentDeliveryJobID > @ETLDeliveryJobId

IF @count >0
BEGIN
	INSERT INTO @SummaryErrorTable
	(
		ETLParameterSummaryJobId,
		ETLParameterDeliveryJobId,
		SummaryControlId,
		SummaryPackageName,
		LastSummaryJobId,
		LastDeliveryJobId,
		CurrentDeliveryJobId
	)
			
		SELECT @ETLSummaryJobId,
			    @ETLDeliveryJobId,
				SummaryControlId,
				SummaryPackageName,
				LastSummaryJobId,
				LastDeliveryJobId,
				CurrentDeliveryJobID 
		FROM dbo.SummaryControl sc 
       		WHERE LastSummaryJobID > @ETLSummaryJobId 
			OR LastDeliveryJobID > @ETLDeliveryJobId
			OR CurrentDeliveryJobID > @ETLDeliveryJobId

	
 DECLARE @SystemName varchar(200)

				SELECT @SystemName = ConfiguredValue 
				FROM SSISConfiguration 
				WHERE ConfigurationFilter = 'SystemName'	
		
 SET @summaryTableHTML += 
				N'<h2> SUMMARY MANAGER </h2>' 

				SET @summaryTableHTML +=
					N'<h2>ETL Reference Summary Control </h2>' +
					N'<table border="1">' +
					N'<th width="100">Summary Control Id</th>' +
					N'<th width="150">Summary Package Name</th>' +
					N'<th width="100">Last Summary Job Id</th>'+
					N'<th width="100">Last Delivery Job Id</th>'+
					N'<th width="100">Current Delivery Job ID</th>'+
					N'<th width="100">ETL Summary Job Id</th>'+  
					N'<th width="100">ETL Delivery Job Id</th>'+
					N'<th width="200">Issue Desc</th>'+
					CAST ( ( 
					SELECT '#F7FE2E'  AS [@bgcolor],
					td = SummaryControlId, '',
					td = SummaryPackageName, '',
					td = LastSummaryJobId, '',
					td = LastDeliveryJobId , '',
					td = CurrentDeliveryJobID , '',
					td = ETLParameterSummaryJobId, '',
					td = ETLParameterDeliveryJobId , '',
					td = IssueDesc, ''
					FROM (	
							SELECT SummaryControlId,
								SummaryPackageName,
								ISNULL(LastDeliveryJobId,'') AS LastDeliveryJobId,
								ISNULL(LastSummaryJobId,'') AS LastSummaryJobId,
								ISNULL(CurrentDeliveryJobID,'') AS CurrentDeliveryJobID,
								ETLParameterSummaryJobId,
								ETLParameterDeliveryJobId,
									CASE WHEN LastSummaryJobId > ETLParameterSummaryJobId
										THEN 'SummaryControlID: '+convert(varchar,SummaryControlId)+' has LastSummaryJobId: '+convert(varchar,LastSummaryJobId)+' is greater than SummaryJobId in ETLParameters: '+ convert(varchar,ETLParameterSummaryJobId)
									 	WHEN LastDeliveryJobId > ETLParameterDeliveryJobId
										THEN 'SummaryControlID: '+convert(varchar,SummaryControlId)+' has LastDeliveryJobId: '+convert(varchar,LastDeliveryJobId)+' is greater than DeliveryJobId in ETLParameters: '+ convert(varchar,ETLParameterDeliveryJobId)
										WHEN CurrentDeliveryJobID > ETLParameterDeliveryJobId
										THEN 'SummaryControlID: '+convert(varchar,SummaryControlId)+' has CurrentDeliveryJobID: '+convert(varchar,CurrentDeliveryJobID)+' is greater than DeliveryJobId in ETLParameters: '+ convert(varchar,ETLParameterDeliveryJobId)
									
									ELSE '' END AS IssueDesc   
								FROM @SummaryErrorTable
								WHERE SummaryControlId IS NOT NULL
						)a
							FOR XML PATH('tr'), TYPE 
					) AS NVARCHAR(MAX) ) +
					N'</table>'

					set @summaryTableHTML +=
					'<br>Legend
					<table border="1" style="border-style: solid">
						<tr>
							<th>Colour</th>  
							<th>Description</th>
						</tr>
						<tr><td bgcolor="#F7FE2E"></td><td>This is a warning that summary manager can be failed because of getting wrong summary job id</td></tr>
					</table>'


	-- Return extract table html
	SELECT @summaryTableHTML
END 
	

END
GO
PRINT N'Creating [dbo].[spSendEmailExtractMaxJobIDFailure]...';


GO

-- ================================================================================
-- Author:		Nghi Ta
-- Create date: 25/6/2014
-- Description:	To send the failed for check max job id in extract layer 
-- History:     
--         Modified By               Modified Date           Reason of Changes
--         Nghi Ta                   2014-7-15               Remove hardcode database name
-- ================================================================================
CREATE PROCEDURE [dbo].[spSendEmailExtractMaxJobIDFailure]
AS
BEGIN
	SET NOCOUNT ON;
	
DECLARE @jobName nvarchar(20)
DECLARE @databaseName nvarchar(200)
DECLARE @tableName nvarchar(200)
DECLARE @ETLExtractJobId int
DECLARE @extractTableHTML  varchar(max)=''

DECLARE @ExtErrorTable TABLE
(
    DataLayer nvarchar(20),
	TableName nvarchar(200),
	MaxExtractJobID int,
	ETLParameterExtractJobId int,
	ExtractControlId int,
	ExtractPackageName varchar(200),
	LastExtractJobId int
)

SET @jobName ='ExtractJobID' 

-- Get Extract Job Id from ETLParameters
SELECT @ETLExtractJobId = ETLParameterValue FROM dbo.ETLParameters 
WHERE ETLParameterName =  @jobName



	DECLARE cur CURSOR FOR 
	SELECT DISTINCT 
		SUBSTRING(ss.ConfiguredValue, 
											CHARINDEX('Initial Catalog', ss.ConfiguredValue) + LEN('Initial CATALOG='), 
											CHARINDEX(';', ss.ConfiguredValue, CHARINDEX('Initial Catalog=', ss.ConfiguredValue))- (CHARINDEX('Initial Catalog=', ss.ConfiguredValue) + LEN('Initial CATALOG='))) collate DATABASE_DEFAULT AS DatabaseName
		,[ExtractTable]  AS 'FullExtractTable'
		FROM dbo.ExtractControl ec
		INNER JOIN [dbo].SourceControl sc ON sc.SourceControlID = ec.DestinationControlID
		INNER JOIN [dbo].SSISConfiguration ss ON sc.SSISConfigurationID = ss.SSISConfigurationID
		WHERE ss.ConfiguredValue LIKE '%Initial Catalog=%' AND ec.ExtractTable IS NOT NULL

	OPEN cur
	FETCH NEXT FROM cur INTO @databaseName, @tableName
	WHILE (@@FETCH_STATUS = 0)

		BEGIN

			DECLARE @sql nvarchar(max)
			DECLARE @isExistExtractJobID int
			DECLARE @fullExtractTable nvarchar(200) = @databaseName+'.'+@tableName
			
			SET @sql = ' SELECT @isExistExtractJobID = count(*)  FROM '+@databaseName+'.INFORMATION_SCHEMA.COLUMNS c
						WHERE c.COLUMN_NAME ='''+@jobName+''' AND  c.TABLE_CATALOG+''.''+c.TABLE_SCHEMA+''.''+c.TABLE_NAME  = REPLACE(REPLACE('''+@fullExtractTable+''',''['',''''),'']'','''')'

		
			Exec sp_executesql @sql,  N'@isExistExtractJobID int OUTPUT',  @isExistExtractJobID = @isExistExtractJobID OUTPUT;
		
			IF @isExistExtractJobID>0
			BEGIN
				DECLARE @maxExtractJobId int
				DECLARE @lastExtractJobId int

			
				SET @sql = ' SELECT @maxExtractJobId = ISNULL(MAX('+@jobName+'),0) FROM '+ @fullExtractTable
		
				Exec sp_executesql @sql,  N'@maxExtractJobId int OUTPUT',  @maxExtractJobId = @maxExtractJobId OUTPUT;

				IF @maxExtractJobId > @ETLExtractJobId
				BEGIN
					INSERT INTO @ExtErrorTable
					(
						DataLayer,
						TableName,
						MaxExtractJobID,
						ETLParameterExtractJobId
					)
					VALUES
					(
						@databaseName,
						@tableName,
						@maxExtractJobId,
						@ETLExtractJobId
					)
		
				END 
			END 
			
	  	FETCH NEXT FROM cur INTO @databaseName, @tableName
	END
	
	CLOSE cur;
	DEALLOCATE cur;

DECLARE @count int
DECLARE @countAllError int
SELECT @count = COUNT(*) FROM dbo.ExtractControl 
				WHERE LastExtractJobID > @ETLExtractJobId
IF @count >0
		BEGIN
			INSERT INTO @ExtErrorTable
			(
			  ETLParameterExtractJobId,
				ExtractControlId,
				ExtractPackageName,
				LastExtractJobId
				
			)
			SELECT @ETLExtractJobId, ExtractControlId,ExtractPackageName,LastExtractJobId FROM dbo.ExtractControl 
				WHERE LastExtractJobID > @ETLExtractJobId

		END 

  SELECT @countAllError = count(*) FROM @ExtErrorTable
  IF @countAllError >0
		BEGIN
		-- Convert error table to HTML format
		DECLARE @SystemName varchar(200)

			SELECT @SystemName = ConfiguredValue 
			FROM SSISConfiguration 
			WHERE ConfigurationFilter = 'SystemName'	
 
		SET @extractTableHTML += 
					N'<h2> EXTRACT MANGER </h2>'

			   IF (SELECT count(*) FROM  @ExtErrorTable WHERE DataLayer IS NOT NULL) >0
						BEGIN
							SET @extractTableHTML += 
								N'<h2> Extract Layer </h2>' +
								N'<table border="1">' +
								N'<tr><th  width="100">Data Layer</th>'+    
								N'<th width="150">Table Name</th>' +
								N'<th  width="100">Max Etract Job ID</th>'+
								N'<th width="100">ETL Extract Job Id</th>'+
								N'<th  width="200">Issue Desc</th>'+
								CAST ( ( 
								SELECT '#F7FE2E'  AS [@bgcolor],
								td = DataLayer, '',
								td = TableName, '',
								td = MaxExtractJobID , '',
								td = ETLParameterExtractJobId, '',
								td = IssueDesc, ''
								FROM (	
										SELECT DataLayer, 
											TableName, 
											MaxExtractJobID,
											ETLParameterExtractJobId, 
											'Table: '+ TableName +' has max ExtractJobID: '+ convert(varchar,MaxExtractJobID)+'  is greater than  ExtractJobID in ETLParameters: '+ convert(varchar,ETLParameterExtractJobId) AS IssueDesc
											 FROM  @ExtErrorTable
											WHERE DataLayer IS NOT NULL
									)a
										FOR XML PATH('tr'), TYPE 
								) AS NVARCHAR(MAX) ) +
								N'</table>'
						END
				   IF (SELECT count(*) FROM  @ExtErrorTable WHERE ExtractControlId IS NOT NULL) >0
						BEGIN
						   SET @extractTableHTML +=
								N'<h2>ETL Reference Extract Control </h2>' +
								N'<table border="1">' +
								N'<th width="100">Extract Control Id</th>' +
								N'<th width="150">Extract Package Name</th>' +
								N'<th width="100">Last Extract Job Id</th>'+
								N'<th width="100">ETL Extract Job Id</th>'+  
								N'<th width="200">Issue Desc</th>'+
								CAST ( ( 
								SELECT '#F7FE2E'  AS [@bgcolor],
								td = ExtractControlId, '',
								td = ExtractPackageName, '',
								td = LastExtractJobId , '',
								td = ETLParameterExtractJobId, '',
								td = IssueDesc, ''
								FROM (	
										SELECT ExtractControlId,
											ExtractPackageName,
											LastExtractJobId,
											ETLParameterExtractJobId,
											 CASE WHEN LastExtractJobId > ETLParameterExtractJobId
												  THEN 'ExtractControlID: '+convert(varchar,ExtractControlId)+' has LastExtractJobId: '+convert(varchar,LastExtractJobId)+' is greater than  ExtractJobID in ETLParameters: '+ convert(varchar,ETLParameterExtractJobId)
											 ELSE '' END AS IssueDesc   
											FROM @ExtErrorTable
											WHERE ExtractControlId IS NOT NULL
									)a
										FOR XML PATH('tr'), TYPE 
								) AS NVARCHAR(MAX) ) +
								N'</table>'
						END 
					set @extractTableHTML +=
									'<br>Legend
									<table border="1" style="border-style: solid">
										<tr>
											<th>Colour</th>  
											<th>Description</th>
										</tr>
										<tr><td bgcolor="#F7FE2E"></td><td>This is a warning that extract manager can be failed because of getting wrong extract job id</td></tr>
									</table>'


		-- Return extract table html
		SELECT @extractTableHTML
		END
END
GO
PRINT N'Creating [dbo].[spSendEmailDeliveryMaxJobIDFailure]...';


GO


-- ================================================================================
-- Author:		Nghi Ta
-- Create date: 26/6/2014
-- Description:	To send the failed for check max job id in base layer 
-- History:     
--         Modified By               Modified Date           Reason of Changes
--         Nghi Ta                   2014-7-15               Remove hardcode database name
-- ================================================================================
CREATE PROCEDURE [dbo].[spSendEmailDeliveryMaxJobIDFailure]
AS
BEGIN
	SET NOCOUNT ON;

DECLARE @jobName nvarchar(20)
DECLARE @databaseName nvarchar(20)=''
DECLARE @tableName nvarchar(100)
DECLARE @ETLDeliveryJobId int
DECLARE @ETLExtractJobId int
DECLARE @deliveryTableHTML  varchar(max)=''

DECLARE @DeliveryErrorTable TABLE
(
    DataLayer nvarchar(20),
	TableName nvarchar(100),
	MaxDeliveryJobID int,
	ETLParameterDeliveryJobId int,
	ETLParameterExtractJobId int,
	DeliveryControlId int,
	DeliveryPackageName varchar(200),
	LastDeliveryJobId int,
	LastExtractJobID int,
	CurrentExtractJobID int
)

SET @jobName ='DeliveryJobID' 

SELECT @databaseName =  SUBSTRING(ss.ConfiguredValue, 
										CHARINDEX('Initial Catalog', ss.ConfiguredValue) + LEN('Initial CATALOG='), 
										CHARINDEX(';', ss.ConfiguredValue, CHARINDEX('Initial Catalog=', ss.ConfiguredValue))- (CHARINDEX('Initial Catalog=', ss.ConfiguredValue) + LEN('Initial CATALOG=')))
										collate DATABASE_DEFAULT 
	FROM  [dbo].SSISConfiguration ss 
	WHERE  ss.ConfigurationFilter = 'ConnStr_DWData_DB'

-- Get Delivery Job Id from ETLParameters
SELECT @ETLDeliveryJobId = ETLParameterValue FROM dbo.ETLParameters 
WHERE ETLParameterName =  @jobName
SELECT @ETLExtractJobId = ETLParameterValue FROM dbo.ETLParameters 
WHERE ETLParameterName =  'ExtractJobID'


DECLARE cur CURSOR FOR 
	SELECT DISTINCT  dc.DeliveryTable FROM dbo.DeliveryControl dc
	WHERE dc.DeliveryTable IS NOT NULL

	OPEN cur
	FETCH NEXT FROM cur
	   INTO  @tableName
 
	WHILE @@FETCH_STATUS = 0
 
	BEGIN

			DECLARE @fullTable nvarchar(300) = @databaseName+'.'+@tableName
			DECLARE @sql nvarchar(max)=''
			DECLARE @maxDeliveryJobId int 
			DECLARE @lastDeliveryJobId int
		    
			SET @sql = ' SELECT @maxDeliveryJobId = ISNULL(MAX('+@jobName+'),0) FROM ' + @fullTable
			
			Exec sp_executesql @sql,  N'@maxDeliveryJobId int OUTPUT',  @maxDeliveryJobId = @maxDeliveryJobId OUTPUT;

			IF @maxDeliveryJobId > @ETLDeliveryJobId
			BEGIN
				INSERT INTO @DeliveryErrorTable
				(
					DataLayer,
					TableName,
					MaxDeliveryJobID,
					ETLParameterDeliveryJobId
				)
				VALUES
				(
					@databaseName,
					@tableName,
					@maxDeliveryJobId,
					@ETLDeliveryJobId
				)
		
			END 

	   FETCH NEXT FROM cur
	   INTO  @tableName
	END
 
	CLOSE cur 
	DEALLOCATE cur 

DECLARE @count int
DECLARE @countAllError int
 SELECT @count = count(*)
			       FROM dbo.DeliveryControl d
			       WHERE LastDeliveryJobID > @ETLDeliveryJobId 
										    OR LastExtractJobID > @ETLExtractJobId
											OR CurrentExtractJobID > @ETLExtractJobId
    IF @count >0
		BEGIN
			INSERT INTO @DeliveryErrorTable
			(
			   ETLParameterDeliveryJobId,
			   ETLParameterExtractJobId,
				DeliveryControlId,
				DeliveryPackageName,
				LastDeliveryJobId,
				LastExtractJobID,
				CurrentExtractJobID
			)
			
			 SELECT @ETLDeliveryJobId, @ETLExtractJobId, DeliveryControlId, DeliveryPackageName, LastDeliveryJobId, LastExtractJobID, CurrentExtractJobID 
			       FROM dbo.DeliveryControl d
			       WHERE LastDeliveryJobID > @ETLDeliveryJobId 
										    OR LastExtractJobID > @ETLExtractJobId
											OR CurrentExtractJobID > @ETLExtractJobId

		END 

  SELECT @countAllError = count(*) FROM @DeliveryErrorTable
  IF @countAllError >0
		BEGIN
		-- Convert error table to HTML format
		DECLARE @SystemName varchar(200)

					SELECT @SystemName = ConfiguredValue 
					FROM SSISConfiguration 
					WHERE ConfigurationFilter = 'SystemName'	
		
		SET @deliveryTableHTML += 
						N'<h2> DELIVERY MANAGER </h2>' 
      
	    IF (SELECT count(*) FROM  @DeliveryErrorTable WHERE DataLayer IS NOT NULL) >0
				BEGIN
					SET @deliveryTableHTML += 
						N'<h2> Base Layer </h2>' +
						N'<table border="1">' +
						N'<tr><th  width="100">Data Layer</th>'+    
						N'<th width="150">Table Name</th>' +
						N'<th  width="100">Max Etract Job ID</th>'+
						N'<th width="100">ETL Extract Job Id</th>'+
						N'<th  width="200">Issue Desc</th>'+
						CAST ( ( 
						SELECT '#F7FE2E'  AS [@bgcolor],
						td = DataLayer, '',
						td = TableName, '',
						td = MaxDeliveryJobID , '',
						td = ETLParameterDeliveryJobId, '',
						td = IssueDesc, ''
						FROM (	
								SELECT DataLayer, 
									TableName, 
									MaxDeliveryJobID,
									ETLParameterDeliveryJobId, 
									'Table: '+ TableName +' has max DeliveryJobID: '+ convert(varchar,MaxDeliveryJobID)+'  is greater than  DeliveryJobID in ETLParameters: '+ convert(varchar,ETLParameterDeliveryJobId) AS IssueDesc
									 FROM  @DeliveryErrorTable
									WHERE DataLayer IS NOT NULL
							)a
								FOR XML PATH('tr'), TYPE 
						) AS NVARCHAR(MAX) ) +
						N'</table>'
				END


	       IF (SELECT count(*) FROM  @DeliveryErrorTable WHERE DeliveryControlId IS NOT NULL) >0
				BEGIN
				   SET @deliveryTableHTML +=
						N'<h2>ETL Reference Delivery Control </h2>' +
						N'<table border="1">' +
						N'<th width="100">Delivery Control Id</th>' +
						N'<th width="150">Delivery Package Name</th>' +
						N'<th width="100">Last Delivery Job Id</th>'+
						N'<th width="100">Last Extract Job Id</th>'+
						N'<th width="100">Current Extract Job ID</th>'+
						N'<th width="100">ETL Delivery Job Id</th>'+  
						N'<th width="100">ETL Extract Job Id</th>'+
						N'<th width="200">Issue Desc</th>'+
						CAST ( ( 
						SELECT '#F7FE2E'  AS [@bgcolor],
						td = DeliveryControlId, '',
						td = DeliveryPackageName, '',
						td = LastDeliveryJobId, '',
						td = LastExtractJobId , '',
						td = CurrentExtractJobID , '',
						td = ETLParameterDeliveryJobId , '',
						td = ETLParameterExtractJobId, '',
						td = IssueDesc, ''
						FROM (	
								SELECT DeliveryControlId,
									DeliveryPackageName,
									LastDeliveryJobId,
									LastExtractJobId,
									CurrentExtractJobID,
									ETLParameterDeliveryJobId,
									ETLParameterExtractJobId,
									 CASE WHEN LastDeliveryJobId > ETLParameterDeliveryJobId
									      THEN 'DeliveryControlID: '+convert(varchar,DeliveryControlId)+' has LastDeliveryJobId: '+convert(varchar,LastDeliveryJobId)+' is greater than DeliveryJobId in ETLParameters: '+ convert(varchar,ETLParameterDeliveryJobId)
									 	  WHEN LastExtractJobId > ETLParameterExtractJobId
									      THEN 'DeliveryControlID: '+convert(varchar,DeliveryControlId)+' has LastExtractJobId: '+convert(varchar,LastExtractJobId)+' is greater than ExtractJobId in ETLParameters: '+ convert(varchar,ETLParameterExtractJobId)
										  WHEN CurrentExtractJobID > ETLParameterExtractJobId
									      THEN 'DeliveryControlID: '+convert(varchar,DeliveryControlId)+' has CurrentExtractJobID: '+convert(varchar,CurrentExtractJobID)+' is greater than  ExtractJobId in ETLParameters: '+ convert(varchar,ETLParameterExtractJobId)
									
									 ELSE '' END AS IssueDesc   
									FROM @DeliveryErrorTable
									WHERE DeliveryControlID IS NOT NULL
							)a
								FOR XML PATH('tr'), TYPE 
						) AS NVARCHAR(MAX) ) +
						N'</table>'
				END 
			set @deliveryTableHTML +=
							'<br>Legend
							<table border="1" style="border-style: solid">
								<tr>
									<th>Colour</th>  
									<th>Description</th>
								</tr>
								<tr><td bgcolor="#F7FE2E"></td><td>This is a warning that delivery manager can be failed because of getting wrong delivery job id</td></tr>
							</table>'


		-- Return extract table html
		SELECT @deliveryTableHTML
	END 

END
GO
PRINT N'Creating [dbo].[spSendEmailStagingFailure]...';


GO
-- =============================================
-- Author:		Nghi Ta
-- Create date: 24/6/2014
-- Description:	To send the failed staging message 
-- =============================================
CREATE PROCEDURE [dbo].[spSendEmailStagingFailure]
  @EmailReceipent varchar(max) = 0,
  @LastErrorEmailChecker DATETIME,
  @ScheduleType NVARCHAR(100)
AS
BEGIN
	SET NOCOUNT ON;
    
	DECLARE @Message AS VARCHAR(MAX)
	DECLARE @LogQuery AS VARCHAR(MAX)
	DECLARE @BodyMessage AS VARCHAR(MAX)
	DECLARE @Importance AS VARCHAR(20)
	DECLARE @count int    
	DECLARE @ProfileName NVARCHAR(255)
	DECLARE @SystemName varchar(max)
	DECLARE @tableHTML  NVARCHAR(MAX) 
    DECLARE @Email_Subject NVARCHAR(255)
    
    
    -- Set variables
	SELECT @ProfileName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'EmailProfileName'
	SELECT @SystemName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'SystemName'
	SELECT @Email_Subject = '!!!Failure!!! - ' + @SystemName + ' Staging Process Failed'
	SELECT @Importance = 'High'

	--Check if a process has failed and no action has been taken
	SELECT @count = COUNT (*)
	FROM [StagingControl] sc (NOLOCK)
					INNER JOIN  dbo.StagingExecutionlog scl(nolock) ON sc.StagingControlID = scl.StagingControlID
					WHERE  (scl.successflag =0 
					AND @LastErrorEmailChecker <= EndTime)
					OR ((sc.Status = 'F' AND [FailedCountEmailSent] IS NULL) -- handle hourly
                    OR (sc.Status = 'F' AND @ScheduleType = 'Daily'))

	IF @count > 0
	BEGIN 
			SET @tableHTML =
			N'<H1>'+@SystemName+' Process Failure</H1>' +
			N'<font size = "3">Hi,<br>' + CHAR(10) + CHAR(10) +
			N'<br>Please check DWReference, the status is reporting that the packages below have failed.<br>  '+
			'This will need to be investigated.' + CHAR(10) + CHAR(10) +
			N'<br>Please do not reply this email as it is auto generated from ' + @SystemName + 
			' system. If you have any questions with this email please contact ' + @SystemName + ' team.</font>'+
			N'<table border="1">' +
			N'<tr><th>StagingControlID</th>'+    
			N'<th>SuiteName</th>' +
			N'<th>StagingPackageName</th>' +
			N'<th>Last Status Change date time</th>'+
			N'<th>Last Package failed date time</th>'+
			N'<th>Package Status</th>'+
			N'<th>Failed Count</th>'+
			CAST ( ( 
			SELECT  CASE WHEN Status = 'F' THEN '#FF0000' 
			             ELSE '#F7FE2E'
			END AS [@bgcolor],
			td = StagingControlID, '',
			td = SuiteName, '',
			td = StagingPackageName, '',
			td = [StatusChangeDateTime] , '',
			td = [EndTime], '',
			td = [status] , '',
			td =  FailedCount , ''
			FROM (	
					SELECT sc.StagingControlID,sc.StagingPackageName, sc.[StatusChangeDateTime], MAX(scl.EndTime) AS 'EndTime', sc.[status], ISNULL(sc.FailedCount,0) AS FailedCount, s.SuiteName
					FROM [StagingControl] sc (NOLOCK)
					INNER JOIN dbo.Suite s (NOLOCK) ON s.SuiteID = sc.SuiteID
					INNER JOIN  dbo.StagingExecutionlog scl(nolock) ON sc.StagingControlID = scl.StagingControlID
					WHERE  (scl.successflag =0 
					AND @LastErrorEmailChecker <= EndTime)
					OR (sc.Status = 'F' AND [FailedCountEmailSent] IS NULL) -- handle hourly
					OR (sc.Status = 'F' AND @ScheduleType = 'Daily')
					GROUP BY sc.StagingControlID,sc.StagingPackageName, sc.[StatusChangeDateTime], sc.[status], ISNULL(sc.FailedCount,0), s.SuiteName
				)a
					FOR XML PATH('tr'), TYPE 
			) AS NVARCHAR(MAX) ) +
			N'</table>
<br>Legend
<table border="1">
	<tr>
		<th>Colour</th>  
		<th>Description</th>
	</tr>
	<tr><td bgcolor="#FF0000"></td><td>The package has failed and will not work until an administrator resets the status</td></tr>
	<tr><td bgcolor="#F7FE2E"></td><td>This is a warning that the package has failed but will continue to work until it hits the max fail count</td></tr>
</table>'

		
			BEGIN
					EXEC	msdb.dbo.sp_send_dbmail
					@profile_name = @ProfileName,
					@recipients = @EmailReceipent,
					@body = @tableHTML,					
					@body_format = 'HTML', 
					@query = @LogQuery ,
					@subject =@Email_Subject,
					@Importance = @Importance
			END				
			
		END 			    
			
		-- Update email sent time	
		UPDATE [StagingControl] 
		SET [FailedCountEmailSent] = GETDATE()
		WHERE Status = 'F' 	
		AND [FailedCountEmailSent] IS NULL
END
GO
PRINT N'Creating [dbo].[CheckerIDAndName]...';


GO

CREATE PROCEDURE [dbo].[CheckerIDAndName]
@OnlyDifferent BIT
AS 
BEGIN 

	SET NOCOUNT ON
	DECLARE @TableName NVARCHAR(MAX)
	DECLARE @ID NVARCHAR(MAX)
	DECLARE @Name NVARCHAR(MAX)
	DECLARE @UniqName NVARCHAR(MAX)
	DECLARE @sqlQuery NVARCHAR(MAX) = ''

	IF OBJECT_ID('tempdb..#CheckTable') IS NOT NULL
	BEGIN
				DROP TABLE #CheckTable
	END
	SELECT TableName, ID, Name,UniqName
	INTO #CheckTable
	FROM (
	SELECT 'SourceControl' AS 'TableName', 'SourceControlID' AS 'ID', 'SourceName' AS 'Name', 'SourceName' AS 'UniqName'
	UNION
	SELECT 'Suite', 'SuiteID', 'SuiteName', 'SuiteName' AS 'UniqName'
	UNION
	SELECT 'SSISConfiguration', 'SSISConfigurationID', 'ConfigurationFilter', 'ConfigurationFilter' AS 'UniqName'
	UNION
	SELECT 'Schedule', 'ScheduleID', 'ScheduleName', 'ScheduleName' AS 'UniqName'
	UNION
	SELECT 'ExtractControl', 'ExtractControlID', 'ExtractPackageName', 'ExtractPackageName + ''_'' + CAST([SuiteID] AS NVARCHAR(10)) + ''_'' + CAST([ExecutionOrderGroup] AS NVARCHAR(10)) ' AS 'UniqName'
	UNION
	SELECT 'ExtractControl', 'SourceQuery', 'ExtractPackageName', 'ExtractPackageName + ''_'' + CAST([SuiteID] AS NVARCHAR(10)) + ''_'' + CAST([ExecutionOrderGroup] AS NVARCHAR(10)) ' AS 'UniqName'
	UNION
	SELECT 'DeliveryControl', 'DeliveryControlID', 'DeliveryPackageName', 'DeliveryPackageName' AS 'UniqName'
	UNION
	SELECT 'SummaryControl', 'SummaryControlID', 'SummaryPackageName', 'SummaryPackageName' AS 'UniqName'
	) a

	WHILE (SELECT COUNT(*) FROM #CheckTable) > 0
	BEGIN

	SELECT TOP 1 @TableName = TableName
					,@ID = ID
					,@Name = Name
					,@UniqName = UniqName
				FROM #CheckTable

	DECLARE @TempTableName NVARCHAR(MAX) = @TableName + @ID
	DECLARE @sql NVARCHAR(MAX) =
	'
	-------------------------------------------------------------------------------
	-- ' + @TableName + ' 
	-------------------------------------------------------------------------------
	IF OBJECT_ID(''tempdb..#DEVTable'') IS NOT NULL
	BEGIN
				DROP TABLE #' + @TempTableName + 'DEVTable
	END
	SELECT ' + @UniqName + ' AS ''' + @Name + ''', ' + @ID +'
	INTO #' + @TempTableName + 'DEVTable
	FROM OPENROWSET(''SQLNCLI'', ''server=05W8F2APSQ03\dev2012;trusted_connection=yes'', ''SELECT * FROM DWReference.dbo.' + @TableName + ''')

	IF OBJECT_ID(''tempdb..#' + @TempTableName + 'sitTable'') IS NOT NULL
	BEGIN
				DROP TABLE #' + @TempTableName + 'sitTable
	END
	SELECT ' + @UniqName + ' AS ''' + @Name + ''', ' + @ID +'
	INTO #' + @TempTableName + 'sitTable
	FROM OPENROWSET(''SQLNCLI'', ''server=05W8F2APSQ03\sit2012;trusted_connection=yes'', ''SELECT * FROM DWReference.dbo.' + @TableName + ''')

	IF OBJECT_ID(''tempdb..#' + @TempTableName + 'uatTable'') IS NOT NULL
	BEGIN
				DROP TABLE #' + @TempTableName + 'uatTable
	END
	SELECT ' + @UniqName + ' AS ''' + @Name + ''', ' + @ID +'
	INTO #' + @TempTableName + 'uatTable
	FROM OPENROWSET(''SQLNCLI'', ''server=05W8F2APSQ03;trusted_connection=yes'', ''SELECT * FROM DWReference.dbo.' + @TableName + ''')
	
	IF OBJECT_ID(''tempdb..#' + @TempTableName + 'ProdTable'') IS NOT NULL
	BEGIN
				DROP TABLE #' + @TempTableName + 'ProdTable
	END
	SELECT ' + @UniqName + ' AS ''' + @Name + ''', ' + @ID +'
	INTO #' + @TempTableName + 'ProdTable
	FROM OPENROWSET(''SQLNCLI'', ''server=60W8F5QVSQ01;trusted_connection=yes'', ''SELECT * FROM DWReference.dbo.' + @TableName + ''')
	
	SELECT DISTINCT un.' + @Name + '
	,d.' + @ID +' AS ''Dev''
	,s.' + @ID +' AS ''Sit''
	,u.' + @ID +' AS ''Uat''
	,p.' + @ID +' AS ''Prod''
	,CASE WHEN ((COALESCE(d.' + @ID +', ''-1'') + COALESCE(d.' + @ID +', ''-1'') + COALESCE(d.' + @ID +', ''-1'') + COALESCE(d.' + @ID +', ''-1'') )
	<> ( COALESCE(d.' + @ID +', ''-1'') + COALESCE(s.' + @ID +', ''-1'') + COALESCE(u.' + @ID +', ''-1'') + COALESCE(p.' + @ID +', ''-1'') )) THEN 1 ELSE 0 END AS ''Different''
	FROM 
		(
			SELECT ' + @Name + ' FROM #' + @TempTableName + 'DEVTable
			UNION SELECT ' + @Name + ' FROM #' + @TempTableName + 'SitTable
			UNION SELECT ' + @Name + ' FROM #' + @TempTableName + 'UATTable
			UNION SELECT ' + @Name + ' FROM #' + @TempTableName + 'ProdTable
		) un        
	LEFT JOIN #' + @TempTableName + 'DEVTable d ON d.' + @Name + ' = un.' + @Name + '
	LEFT JOIN #' + @TempTableName + 'SitTable s ON s.' + @Name + ' = un.' + @Name + '
	LEFT JOIN #' + @TempTableName + 'UATTable u ON u.' + @Name + ' = un.' + @Name + '
	LEFT JOIN #' + @TempTableName + 'ProdTable p ON p.' + @Name + ' = un.' + @Name + '
	'
	
	IF @OnlyDifferent = 1
	BEGIN
	SET @sql = @sql + '	WHERE ((COALESCE(d.' + @ID +', ''-1'') + COALESCE(d.' + @ID +', ''-1'') + COALESCE(d.' + @ID +', ''-1'') + COALESCE(d.' + @ID +', ''-1'') )
	<> ( COALESCE(d.' + @ID +', ''-1'') + COALESCE(s.' + @ID +', ''-1'') + COALESCE(u.' + @ID +', ''-1'') + COALESCE(p.' + @ID +', ''-1'') ))
	'
	END

	SET @sql = @sql + 'ORDER BY d.' + @ID +'

	IF OBJECT_ID(''tempdb..#' + @TempTableName + 'DEVTable'') IS NOT NULL
	BEGIN
				DROP TABLE #' + @TempTableName + 'DEVTable
	END
	IF OBJECT_ID(''tempdb..#' + @TempTableName + 'SitTable'') IS NOT NULL
	BEGIN
				DROP TABLE #' + @TempTableName + 'SitTable
	END
	IF OBJECT_ID(''tempdb..#' + @TempTableName + 'UatTable'') IS NOT NULL
	BEGIN
				DROP TABLE #' + @TempTableName + 'UatTable
	END
	IF OBJECT_ID(''tempdb..#' + @TempTableName + 'ProdTable'') IS NOT NULL
	BEGIN
				DROP TABLE #' + @TempTableName + 'ProdTable
	END
	'

	SET @sqlQuery = @sqlQuery + @sql

	DELETE
	FROM #CheckTable
	WHERE TableName = @TableName AND ID = @ID AND Name = @Name
	END

	IF OBJECT_ID('tempdb..#CheckTable') IS NOT NULL
	BEGIN
				DROP TABLE #CheckTable
	END
	--SET @sqlQuery = REPLACE(@sqlQuery, '''', '''''')
	EXEC [dbo].[LongPrintN] @sqlQuery
	EXEC sp_executesql @sqlQuery;
END
GO
PRINT N'Creating [dbo].[spGetStagingExecutionBulkSqlVariables]...';


GO
CREATE PROCEDURE [dbo].[spGetStagingExecutionBulkSqlVariables]
	@StagingControlID INT
AS
BEGIN
	SET NOCOUNT ON;
-------------------------------------------------------------------------------
-- Retrieve values
-------------------------------------------------------------------------------

DECLARE @JobID INT
DECLARE @TempJob TABLE
(
   JobID INT  
)

INSERT INTO @TempJob 
EXEC [dbo].[spGetJobID] @Type = 'StagingJobID'

SELECT @JobID = JobID FROM @TempJob

SELECT 
@JobID AS 'StagingJobID',
sconp.[ConfiguredValue] AS 'ConnStr_Source',
scons.[ConfiguredValue] AS 'ConnStr_Staging',
st.SourceTypeName as 'SourceTypeName'
FROM dbo.StagingControl sc 
INNER JOIN dbo.SourceControl scp ON sc.SourceControlID = scp.SourceControlID
INNER JOIN dbo.SSISConfiguration sconp ON sconp.[SSISConfigurationID] = scp.SSISConfigurationID
INNER JOIN dbo.SourceControl scs ON sc.StagingDestControlID = scs.SourceControlID
INNER JOIN dbo.SSISConfiguration scons ON scons.[SSISConfigurationID] = scs.SSISConfigurationID
INNER JOIN dbo.SourceType st ON scp.SourceTypeID = st.SourceTypeID
WHERE sc.StagingControlID = @StagingControlID
END
GO
PRINT N'Creating [Audit].[AuditTriggerGen]...';


GO


CREATE PROC [Audit].[AuditTriggerGen]
AS
BEGIN
DECLARE @SchemaName NVARCHAR(250)
DECLARE @TableName NVARCHAR(250)
DECLARE @ColumnName NVARCHAR(250)
DECLARE @DataType NVARCHAR(250)
DECLARE	@ColumnNames NVARCHAR(MAX) = ''
DECLARE	@ColumnDeleteNames NVARCHAR(MAX) = ''
DECLARE @PKCols NVARCHAR(MAX) = ''
DECLARE @PKFieldSelect NVARCHAR(MAX) = ''
DECLARE @PKValueSelect NVARCHAR(MAX) = ''
DECLARE @SqlQuery NVARCHAR(MAX) = ''



DECLARE	@ColumnInsertValuesNames NVARCHAR(MAX) = ''
DECLARE	@ColumnDeleteValuesNames NVARCHAR(MAX) = ''

DECLARE	@InsertStatement NVARCHAR(MAX) = ''

SET NOCOUNT ON

IF OBJECT_ID('tempdb..#AuditTables') IS NOT NULL
DROP TABLE #AuditTables

SELECT DISTINCT [SchemaName], [TableName]
INTO #AuditTables
FROM [Audit].[AuditMonitorTableColumns]

WHILE (SELECT COUNT(*) FROM #AuditTables) > 0
BEGIN

	SELECT TOP 1 @SchemaName = SchemaName, @TableName = TableName
	FROM #AuditTables

    SET @ColumnNames = ''
    SET	@ColumnDeleteNames = ''
	SET @ColumnInsertValuesNames = ''
	SET @ColumnDeleteValuesNames = ''
	SET @InsertStatement = ''
	SET @PKCols = ''
	SET @PKFieldSelect = ''
	SET @PKValueSelect = ''
	SET @SqlQuery = ''
	
	IF OBJECT_ID('tempdb..#AuditTableDetails') IS NOT NULL
	DROP TABLE #AuditTableDetails

	SELECT tc.[ColumnName], UPPER(DATA_TYPE) + COALESCE('(' + CAST(CHARACTER_MAXIMUM_LENGTH AS NVARCHAR(10) )+ ')', '') AS 'DataType'
	INTO #AuditTableDetails
	FROM [Audit].[AuditMonitorTableColumns] tc
	INNER JOIN INFORMATION_SCHEMA.COLUMNS sc ON sc.COLUMN_NAME = tc.ColumnName AND tc.TableName = sc.TABLE_NAME AND sc.TABLE_SCHEMA = tc.SchemaName
	WHERE TableName = @TableName

	-- Get primary key columns for full outer join
	SELECT  @PKCols = CASE WHEN LEN(@PKCols) = 0
						   THEN COALESCE(@PKCols, ' on') + ' i.' + c.COLUMN_NAME + ' = d.' + c.COLUMN_NAME
						   ELSE COALESCE(@PKCols + ' and', ' on') + ' i.'  + c.COLUMN_NAME + ' = d.' + c.COLUMN_NAME
					  END
	FROM    INFORMATION_SCHEMA.TABLE_CONSTRAINTS pk ,
			INFORMATION_SCHEMA.KEY_COLUMN_USAGE c
	WHERE   pk.TABLE_NAME = @TableName
			AND CONSTRAINT_TYPE = 'PRIMARY KEY'
			AND c.TABLE_NAME = pk.TABLE_NAME
			AND c.CONSTRAINT_NAME = pk.CONSTRAINT_NAME

	-- Get primary key fields select for insert(comma deparated)           
	SELECT  @PKFieldSelect = CASE WHEN LEN(@PKFieldSelect) = 0
								  THEN COALESCE(@PKFieldSelect, '') + COLUMN_NAME
								  ELSE COALESCE(@PKFieldSelect + ' + ', '') + COLUMN_NAME
							 END
	FROM    INFORMATION_SCHEMA.TABLE_CONSTRAINTS pk ,
			INFORMATION_SCHEMA.KEY_COLUMN_USAGE c
	WHERE   pk.TABLE_NAME = @TableName
			AND CONSTRAINT_TYPE = 'PRIMARY KEY'
			AND c.TABLE_NAME = pk.TABLE_NAME
			AND c.CONSTRAINT_NAME = pk.CONSTRAINT_NAME

	-- Get primary key values for insert(comma deparated as varchar)           
	SELECT --@PKValueSelect = coalesce(@PKValueSelect+'+','') + 'convert(varchar(100), coalesce(i.' + COLUMN_NAME + ',d.' + COLUMN_NAME + '))' + '+'',''' 
			@PKValueSelect = CASE WHEN LEN(@PKValueSelect) = 0
								  THEN 'convert(varchar(100), coalesce(i.' + COLUMN_NAME + ',d.' + COLUMN_NAME + '))'
								  ELSE COALESCE(@PKValueSelect + ' + '','' + ', '') + 'convert(varchar(100), coalesce(i.' + COLUMN_NAME + ',d.' + COLUMN_NAME + '))'
							 END
	FROM    INFORMATION_SCHEMA.TABLE_CONSTRAINTS pk ,
			INFORMATION_SCHEMA.KEY_COLUMN_USAGE c
	WHERE   pk.TABLE_NAME = @TableName
			AND CONSTRAINT_TYPE = 'PRIMARY KEY'
			AND c.TABLE_NAME = pk.TABLE_NAME
			AND c.CONSTRAINT_NAME = pk.CONSTRAINT_NAME 

	WHILE (SELECT COUNT(*) FROM #AuditTableDetails) > 0
	BEGIN
		SELECT TOP 1 @ColumnName = [ColumnName], @DataType = DataType FROM #AuditTableDetails

		SET @InsertStatement = @InsertStatement + '
INSERT INTO Audit.AuditData (Type, TableName, PrimaryKeyField, PrimaryKeyValue, FieldName, OldValue, NewValue, UpdateDate, UserName)
SELECT @Type, @TableName, @PKFieldSelect, ' + @PKValueSelect +', ''' + @ColumnName + ''', CONVERT(NVARCHAR(MAX), d.' + @ColumnName + '), CONVERT(NVARCHAR(MAX),i.' + @ColumnName + '),@UpdateDate,@UserName
FROM inserted i FULL OUTER JOIN deleted d ON ' + @PKCols + '
WHERE i.' + @ColumnName + ' <> d.' + @ColumnName + ' OR i.' + @ColumnName + ' IS NULL AND d.' + @ColumnName + ' IS NOT NULL OR i.' + @ColumnName + ' IS NOT NULL AND d.' + @ColumnName + ' IS NULL
'




		DELETE FROM #AuditTableDetails WHERE [ColumnName] = @ColumnName
	END
	DELETE FROM #AuditTables WHERE SchemaName = @SchemaName AND TableName = @TableName

SET @SqlQuery = 'SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects o
               INNER JOIN sys.schemas s ON s.schema_id = o.schema_id
			   WHERE  o.[type] = ''TR'' AND  o.[name] = ''' + @TableName + '_ChangeTracking'' AND s.name = ''' + @SchemaName + ''')
  BEGIN 
    EXEC (''CREATE TRIGGER [' + @SchemaName + '].[' + @TableName + '_ChangeTracking] ON [' + @SchemaName + '].[' + @TableName + '] FOR INSERT, UPDATE, DELETE
            AS
            BEGIN
               SELECT 1
            END'')  
  END 
GO  

ALTER TRIGGER [' + @SchemaName + '].[' + @TableName + '_ChangeTracking] on [' + @SchemaName + '].[' + @TableName + '] FOR INSERT, UPDATE, DELETE
AS
SET NOCOUNT ON
DECLARE @TableName varchar(128) = ''[' + @SchemaName + '].[' + @TableName + ']''
DECLARE @UpdateDate varchar(21)
DECLARE @UserName varchar(128)
DECLARE @Type char(1)
DECLARE @PKFieldSelect nvarchar(1000) = ''' + @PKFieldSelect + '''
DECLARE @PKValueSelect nvarchar(1000)
 
-- date and user
SELECT @UserName = SYSTEM_USER , @UpdateDate = CONVERT(VARCHAR(8), GETDATE(), 112) + '' '' + CONVERT(VARCHAR(12), GETDATE(), 114)
' + @ColumnNames + '
' + @ColumnDeleteNames + '

-- Action
IF EXISTS (SELECT * FROM inserted)
BEGIN
	--SELECT ' + @ColumnInsertValuesNames + ' FROM inserted
	IF EXISTS (SELECT * FROM deleted)
	BEGIN
	--	SELECT ' + @ColumnDeleteValuesNames + ' FROM deleted
		SELECT @Type = ''U''
	END
	ELSE
	BEGIN
		SELECT @Type = ''I''
	END
END
ELSE
BEGIN
	--SELECT ' + @ColumnDeleteValuesNames + ' FROM deleted
	SELECT @Type = ''D''
END

' + @InsertStatement + '
GO'

EXEC LongPrintN @SqlQuery
END
END
GO
PRINT N'Creating [dbo].[spUpdateExtractExecutionStatus]...';


GO



CREATE PROCEDURE [dbo].[spUpdateExtractExecutionStatus]
	@ExtractControlID INT,
	@Status VARCHAR(1)
	
AS
BEGIN
DECLARE @FailedCount INT
DECLARE @ScheduleID INT
DECLARE @GetDate DATETIME
DECLARE @NextRunDateTime DATETIME


	IF EXISTS (SELECT 1 FROM ExtractControl WHERE ExtractControlID = @ExtractControlID )
	BEGIN

		SELECT @FailedCount = ISNULL(FailedCount, 0) 
		FROM ExtractControl 
		WHERE ExtractControlID = @ExtractControlID 



		IF @Status = 'F'
		AND @FailedCount <= 1
		BEGIN
		UPDATE ExtractControl
			SET Status = 'S',
			FailedCount = @FailedCount + 1,
			FailedCountEmailSent = NULL,
			StatusChangeDateTime = GETDATE()	
			WHERE ExtractControlID = @ExtractControlID 
		END
		ELSE IF @Status = 'S'
		BEGIN
			SELECT @ScheduleID = ScheduleID FROM dbo.ExtractControl WHERE ExtractControlID = @ExtractControlID
			SET @GetDate = GETDATE()

			EXEC [dbo].[spGetNextTime] @GetDate, @ScheduleID, @NextRunDateTime OUTPUT

			UPDATE ExtractControl
			SET Status = @Status,
			FailedCount = 0,
			StatusChangeDateTime = GETDATE(),
			FailedCountEmailSent = NULL,
			MaxExpectedExecutionEmailSent = NULL,
			NextRunDateTime = @NextRunDateTime
			WHERE ExtractControlID = @ExtractControlID 
		END
		ELSE
		BEGIN
			UPDATE ExtractControl
			SET Status = @Status,
			StatusChangeDateTime = GETDATE(),
			FailedCountEmailSent = NULL,
			MaxExpectedExecutionEmailSent = NULL
			WHERE ExtractControlID = @ExtractControlID 
		END
	END
END
GO
PRINT N'Creating [dbo].[spGetExtractExecutionStandardVariables]...';


GO

CREATE PROCEDURE [dbo].[spGetExtractExecutionStandardVariables]
	@ExtractControlID INT
AS
BEGIN
	SET NOCOUNT ON;
-------------------------------------------------------------------------------
-- Set Status
-------------------------------------------------------------------------------
EXEC spUpdateExtractExecutionStatus @ExtractControlID, 'P'
-------------------------------------------------------------------------------
-- Retrieve values
-------------------------------------------------------------------------------
SELECT
COALESCE(ec.ExtractPackageName,'') AS 'ExtractPackageName',
COALESCE(sComp.SuiteName, s.SuiteName,'') AS 'Suite',
CONVERT(CHAR(23), GETDATE(), 121) AS StartTime,
ec.ExecutionOrder,
scSource.AccessWindowEndMins,
COALESCE(ec.ExtractPackagePath,'') AS 'ExtractPackagePath',
COALESCE(ec.ExtractTable,'') AS 'ExtractTable',
COALESCE(dbo.udfPackagePathName(scEnv.ConfiguredValue, ec.ExtractPackagePath, ec.ExtractPackageName), '') AS 'ExtractPathAndName',
COALESCE(scEnv.ConfiguredValue,'') AS 'Environment',
COALESCE(scSrv.ConfiguredValue,'') AS 'Server',
COALESCE(scMSDB.ConfiguredValue,'') AS 'ConnStr_msdb',
CONVERT(CHAR(23), ec.ExtractStartTime, 121) AS ExtractStartTime,
COALESCE(ec.ConnectionCheckQuery, '') AS ConnectionCheckQuery,
CASE 
	WHEN ec.CheckConnection = 'False' THEN 0 
	ELSE ec.ConnectionCheckResult
END AS ConnectionCheckResult,
COALESCE(ec.DataCurrencyCheckQuery, '') AS DataCurrencyCheckQuery,
CASE 
	WHEN ec.CheckDataCurrency = 'False' THEN 0 
	ELSE ec.DataCurrencyCheckResult
END AS DataCurrencyCheckResult,
COALESCE(ec.CheckConnection, 'False') AS CheckConnection,
COALESCE(ec.CheckDataCurrency, 'False') AS CheckDataCurrency,
ec.CheckExtractRowCount,
COALESCE(ec.ProcessType,'') AS 'ProcessType',
COALESCE(ec.SourceQuery,'') AS 'SourceQuery',
COALESCE(ec.SourceQueryMapping,'') AS 'SourceQueryMapping',
ec.TruncateExtractTable,
COALESCE(scBup.ConfiguredValue, '') AS 'BulkUploadLoadSize'
FROM dbo.ExtractControl ec 
INNER JOIN dbo.Suite s ON ec.SuiteID = s.SuiteID
INNER JOIN dbo.SourceControl scSource ON ec.SourceControlID = scSource.SourceControlID
INNER JOIN dbo.SSISConfiguration scEnv ON scEnv.ConfigurationFilter = 'Environment'
INNER JOIN dbo.SSISConfiguration scSrv ON scSrv.ConfigurationFilter = 'Server'
INNER JOIN dbo.SSISConfiguration scMSDB ON scMSDB.ConfigurationFilter = 'ConnStr_msdb'
INNER JOIN dbo.SSISConfiguration scBup ON scBup.ConfigurationFilter = 'BulkUploadLoadSize'
LEFT JOIN dbo.Suite sComp ON ec.CompanySuiteID = sComp.SuiteID
WHERE ec.ExtractControlID = @ExtractControlID
END
GO
PRINT N'Creating [dbo].[spGetExtractExecutionSqlFileVariables]...';


GO

CREATE PROCEDURE [dbo].[spGetExtractExecutionSqlFileVariables]
	@ExtractControlID INT
AS
BEGIN
	SET NOCOUNT ON;
-------------------------------------------------------------------------------
-- Set Status
-------------------------------------------------------------------------------
EXEC spUpdateExtractExecutionStatus @ExtractControlID, 'P'
-------------------------------------------------------------------------------
-- Retrieve values
-------------------------------------------------------------------------------
SELECT
ec.ExtractControlID,
CONVERT(CHAR(23), GETDATE(), 121) AS StartTime,
ec.ExecutionOrder,
scSource.AccessWindowEndMins,
ec.ExtractPackagePath,
ec.ExtractTable,
CONVERT(CHAR(23), ec.ExtractStartTime, 121) AS ExtractStartTime,
COALESCE(ec.RunAs32Bit, 'False') AS RunAs32bit,
sscSource.ConfiguredValue AS 'ConnStr_Source',
sscDestination.ConfiguredValue AS 'FileDestination',
ec.ExtractTable AS 'FileName'
FROM dbo.ExtractControl ec 
INNER JOIN dbo.Suite s ON ec.SuiteID = s.SuiteID
INNER JOIN dbo.SourceControl scSource ON ec.SourceControlID = scSource.SourceControlID
INNER JOIN dbo.SSISConfiguration sscSource ON sscSource.SSISConfigurationID = scSource.SSISConfigurationID
INNER JOIN dbo.SourceControl scDestination ON ec.DestinationControlID = scDestination.SourceControlID
INNER JOIN dbo.SSISConfiguration sscDestination ON sscDestination.SSISConfigurationID = scDestination.SSISConfigurationID
WHERE ec.ExtractControlID = @ExtractControlID
END
GO
PRINT N'Creating [dbo].[spUpdateStagingExecutionStatus]...';


GO


CREATE PROCEDURE [dbo].[spUpdateStagingExecutionStatus]
	@StagingControlID INT,
	@Status VARCHAR(1)
	
AS
BEGIN
DECLARE @FailedCount INT
DECLARE @ScheduleID INT
DECLARE @GetDate DATETIME
DECLARE @NextRunDateTime DATETIME


	IF EXISTS (SELECT 1 FROM StagingControl WHERE StagingControlID = @StagingControlID )
	BEGIN

		SELECT @FailedCount = ISNULL(FailedCount, 0) 
		FROM StagingControl 
		WHERE StagingControlID = @StagingControlID 



		IF @Status = 'F'
		AND @FailedCount <= 1
		BEGIN
		UPDATE StagingControl
			SET Status = 'S',
			FailedCount = @FailedCount + 1,
			FailedCountEmailSent = NULL,
			StatusChangeDateTime = GETDATE()	
			WHERE StagingControlID = @StagingControlID 
		END
		ELSE IF @Status = 'S'
		BEGIN
			SELECT @ScheduleID = ScheduleID FROM dbo.StagingControl WHERE StagingControlID = @StagingControlID
			SET @GetDate = GETDATE()

			IF(@ScheduleID IS NOT NULL)
			BEGIN
				EXEC [dbo].[spGetNextTime] @GetDate, @ScheduleID, @NextRunDateTime OUTPUT
			END

			UPDATE StagingControl
			SET Status = @Status,
			FailedCount = 0,
			StatusChangeDateTime = GETDATE(),
			FailedCountEmailSent = NULL,
			MaxExpectedExecutionEmailSent = NULL,
			NextRunDateTime = @NextRunDateTime
			WHERE StagingControlID = @StagingControlID 
		END
		ELSE
		BEGIN
			UPDATE StagingControl
			SET Status = @Status,
			StatusChangeDateTime = GETDATE(),
			FailedCountEmailSent = NULL,
			MaxExpectedExecutionEmailSent = NULL
			WHERE StagingControlID = @StagingControlID 
		END
	END
END
GO
PRINT N'Creating [dbo].[spSendEmailMaxJobIDChecker]...';


GO
-- =============================================
-- Author:		Nghi Ta
-- Create date: 25/6/2014
-- Description:	To send the failed for check max job id
-- =============================================
CREATE PROCEDURE [dbo].[spSendEmailMaxJobIDChecker]
  @EmailReceipent varchar(max) = 0
AS
BEGIN
	SET NOCOUNT ON;
    
	DECLARE @Message AS VARCHAR(MAX)
	DECLARE @LogQuery AS VARCHAR(MAX)
	DECLARE @BodyMessage AS VARCHAR(MAX)
	DECLARE @Importance AS VARCHAR(20)
	DECLARE @count int    
	DECLARE @ProfileName NVARCHAR(255)
	DECLARE @SystemName varchar(max)

    DECLARE @Email_Subject NVARCHAR(255)
	DECLARE @contentHTML varchar(max) =''
	
	DECLARE @tableHTML TABLE
	(
		content varchar(max)
	)
   
    -- Set variables
	SELECT @ProfileName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'EmailProfileName'
	SELECT @SystemName = ConfiguredValue FROM SSISConfiguration WHERE ConfigurationFilter = 'SystemName'
	SELECT @Email_Subject = '!!!Failure!!! - ' + @SystemName + ' Check Max Job ID Process Failed'
	SELECT @Importance = 'High'

	--Check if a process has failed and no action has been taken
	INSERT @tableHTML EXECUTE dbo.spSendEmailExtractMaxJobIDFailure
	INSERT @tableHTML EXECUTE dbo.spSendEmailDeliveryMaxJobIDFailure
	INSERT @tableHTML EXECUTE dbo.spSendEmailSummaryMaxJobIDFailure
	
	IF( SELECT count(*) FROM @tableHTML) >0
		BEGIN 
				SET @contentHTML +=
						N'<H1>'+@SystemName+' Process Failure</H1>' +
						N'<font size = "3">Hi,<br>' + CHAR(10) + CHAR(10) +
						N'<br>Please check DWReference, the status is reporting that the packages below have failed.<br>  '+
						'This will need to be investigated.' + CHAR(10) + CHAR(10) +
						N'<br>Please do not reply this email as it is auto generated from ' + @SystemName + 
						' system. If you have any questions with this email please contact ' + @SystemName + ' team.</font>'

				SELECT @contentHTML = @contentHTML + content +'<br>' FROM @tableHTML

						EXEC	msdb.dbo.sp_send_dbmail
						@profile_name = @ProfileName,
						@recipients = @EmailReceipent,
						@body = @contentHTML,					
						@body_format = 'HTML', 
						@query = @LogQuery ,
						@subject =@Email_Subject,
						@Importance = @Importance
		END 
END
GO
PRINT N'Creating [dbo].[spSendEmailChecker]...';


GO

-- =============================================
-- Author:		Olof Szymczak
-- Create date: 16/12/2013
-- Description:	To send failed message 
-- =============================================
CREATE PROCEDURE [dbo].[spSendEmailChecker] 
  @ScheduleType NVARCHAR(100)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @ETLParameterName NVARCHAR(50)
	DECLARE @ScheduleID INT
	DECLARE @ScheduleName NVARCHAR(100)  
	DECLARE @LastErrorEmailChecker DATETIME
	DECLARE @EmailReceipent NVARCHAR(255)
    
	IF @ScheduleType = 'Daily'
	BEGIN
		SET @ScheduleName = 'ErrorEmailCheckDaily'
		SET @ETLParameterName = 'LastErrorDailyEmailChecker'
	END
	ELSE 
	BEGIN 
		SET @ScheduleName = 'ErrorEmailCheckHourly'
		SET @ETLParameterName = 'LastErrorHourlyEmailChecker'
	END

	SELECT @ScheduleID = [ScheduleID] FROM [dbo].[Schedule] WHERE ScheduleName = @ScheduleName
	
	SELECT @LastErrorEmailChecker = [ETLParameterValue] FROM [dbo].[ETLParameters] WHERE [ETLParameterName] = @ETLParameterName
	
	SELECT @EmailReceipent = [ConfiguredValue] FROM [dbo].[SSISConfiguration] WHERE [ConfigurationFilter] = 'EmailReceipent'
	
	EXEC [dbo].[spSendEmailStagingFailure] @EmailReceipent = @EmailReceipent, @LastErrorEmailChecker = @LastErrorEmailChecker, @ScheduleType = @ScheduleType
	EXEC [dbo].[spSendEmailExtractFailure] @EmailReceipent = @EmailReceipent, @LastErrorEmailChecker = @LastErrorEmailChecker, @ScheduleType = @ScheduleType
	EXEC [dbo].[spSendEmailProcessHanging] @EmailReceipent = @EmailReceipent, @ScheduleType = @ScheduleType
	EXEC [dbo].[spSendEmailDeliveryFailure]  @EmailReceipent = @EmailReceipent, @LastErrorEmailChecker = @LastErrorEmailChecker, @ScheduleType = @ScheduleType
	EXEC [dbo].[spSendEmailSummaryFailure]  @EmailReceipent = @EmailReceipent, @LastErrorEmailChecker = @LastErrorEmailChecker, @ScheduleType = @ScheduleType
	EXEC [dbo].[spSendEmailMaxJobIDChecker] @EmailReceipent = @EmailReceipent
	EXEC [dbo].[spSendEmailStagingMaxExpectedDurationBetweenFiles]  @EmailReceipent = @EmailReceipent, @LastErrorEmailChecker = @LastErrorEmailChecker

	UPDATE [dbo].[ETLParameters] SET [ETLParameterValue]  = GETDATE() WHERE [ETLParameterName] = @ETLParameterName
END
GO
PRINT N'Creating [dbo].[spGetExtractExecutionSourceDestType]...';


GO

CREATE PROCEDURE [dbo].[spGetExtractExecutionSourceDestType]
	@ExtractControlID INT
AS
BEGIN
	SET NOCOUNT ON;	
-------------------------------------------------------------------------------
-- Set Status
-------------------------------------------------------------------------------
EXEC spUpdateExtractExecutionStatus @ExtractControlID, 'P'
-------------------------------------------------------------------------------
-- Retrieve values
-------------------------------------------------------------------------------
SELECT stSource.SourceTypeName AS 'SourceTypeName',
stDest.SourceTypeName AS 'DestinationSourceTypeName'
FROM dbo.ExtractControl ec
INNER JOIN dbo.SourceControl scSource ON ec.SourceControlID = scSource.SourceControlID
INNER JOIN dbo.SourceType stSource ON stSource.SourceTypeID = scSource.SourceTypeID
INNER JOIN dbo.SourceControl scDestination ON ec.DestinationControlID = scDestination.SourceControlID
INNER JOIN dbo.SourceType stDest ON stDest.SourceTypeID = scDestination.SourceTypeID
WHERE ec.ExtractControlID = @ExtractControlID
END
GO
PRINT N'Creating [dbo].[spGetExtractExecutionFileVariables]...';


GO
-- =============================================
-- Author:	oszymczak
-- Create date: 03/08/2011
-- Description:	Get Extract Execution Variables
-- =============================================
CREATE PROCEDURE [dbo].[spGetExtractExecutionFileVariables]
	@ExtractControlID INT
AS
BEGIN
	SET NOCOUNT ON;
-------------------------------------------------------------------------------
-- Set Status
-------------------------------------------------------------------------------
EXEC spUpdateExtractExecutionStatus @ExtractControlID, 'P'
-------------------------------------------------------------------------------
-- Retrieve values
-------------------------------------------------------------------------------
SELECT
ec.ExtractControlID,
CONVERT(CHAR(23), GETDATE(), 121) AS StartTime,
ec.ExecutionOrder,
scSource.AccessWindowEndMins,
ec.ExtractPackagePath,
ec.ExtractTable,
CONVERT(CHAR(23), ec.ExtractStartTime, 121) AS ExtractStartTime,
COALESCE(ec.RunAs32Bit, 'False') AS RunAs32bit,
sscSource.ConfiguredValue AS 'ConnStr_Source',
sscDestination.ConfiguredValue AS 'FileDestination',
ec.ExtractTable AS 'FileName'
FROM dbo.ExtractControl ec 
INNER JOIN dbo.Suite s ON ec.SuiteID = s.SuiteID
INNER JOIN dbo.SourceControl scSource ON ec.SourceControlID = scSource.SourceControlID
INNER JOIN dbo.SSISConfiguration sscSource ON sscSource.SSISConfigurationID = scSource.SSISConfigurationID
INNER JOIN dbo.SourceControl scDestination ON ec.DestinationControlID = scDestination.SourceControlID
INNER JOIN dbo.SSISConfiguration sscDestination ON sscDestination.SSISConfigurationID = scDestination.SSISConfigurationID
WHERE ec.ExtractControlID = @ExtractControlID
END
GO
PRINT N'Creating [dbo].[spGetExtractExecutionDestinationType]...';


GO

CREATE PROCEDURE [dbo].[spGetExtractExecutionDestinationType]
	@ExtractControlID INT
AS
BEGIN
	SET NOCOUNT ON;
-------------------------------------------------------------------------------
-- Set Status
-------------------------------------------------------------------------------
EXEC spUpdateExtractExecutionStatus @ExtractControlID, 'P'


-------------------------------------------------------------------------------
-- Retrieve values
-------------------------------------------------------------------------------
SELECT st.SourceTypeName AS 'DestinationSourceTypeName'
FROM dbo.ExtractControl ec
INNER JOIN dbo.SourceControl scDestination ON ec.DestinationControlID = scDestination.SourceControlID
INNER JOIN dbo.SourceType st ON st.SourceTypeID = scDestination.SourceTypeID
WHERE ec.ExtractControlID = @ExtractControlID
END
GO
PRINT N'Creating [dbo].[spInsertExtractExecutionLog]...';


GO
CREATE PROCEDURE [dbo].[spInsertExtractExecutionLog]
	@ExtractJobID INT,
    @StartTime VARCHAR(50),
	@ManagerGUID UNIQUEIDENTIFIER,
    @SuccessFlag INT,
    @CompletedFlag INT,
    @MessageSource VARCHAR(1000),
    @Message VARCHAR(MAX),
    @RowsExtracted INT,
    @ExtractStartTime VARCHAR(50),
    @ExtractEndTime VARCHAR(50),
    @NextExtractStartTime VARCHAR(50),
    @ExtractPackagePathAndName VARCHAR(250),
    @ExtractControlID INT
AS
BEGIN
	SET NOCOUNT ON;

DECLARE @ExtractPackageName VARCHAR(50)
DECLARE @ExtractPackagePath VARCHAR(200)
DECLARE @SourceControlID INT
DECLARE @SourceControlValue VARCHAR(255)
DECLARE @DestinationControlID INT
DECLARE @DestinationControlValue VARCHAR(255)
DECLARE @SuiteID INT
DECLARE @SuiteName VARCHAR(50)
DECLARE @ExecutionOrder INT

SELECT 	@ExtractPackageName = ec.ExtractPackageName,
@ExtractPackagePath = ec.ExtractPackagePath,
@SourceControlID = ec.SourceControlID,
@SourceControlValue = SourceSSC.ConfiguredValue,
@DestinationControlID = ec.DestinationControlID,
@DestinationControlValue = DestinationSSC.ConfiguredValue,
@SuiteID = ec.SuiteID,
@SuiteName = s.SuiteName,
@ExecutionOrder = ec.ExecutionOrder
FROM dbo.ExtractControl ec
INNER JOIN dbo.Suite s ON ec.SuiteID = s.SuiteID
INNER JOIN dbo.SourceControl SourceSC ON ec.SourceControlID = SourceSC.SourceControlID
INNER JOIN dbo.SSISConfiguration SourceSSC ON SourceSC.SSISConfigurationID = SourceSSC.SSISConfigurationID
INNER JOIN dbo.SourceControl DestinationSC ON ec.DestinationControlID = DestinationSC.SourceControlID
INNER JOIN dbo.SSISConfiguration DestinationSSC ON DestinationSC.SSISConfigurationID = DestinationSSC.SSISConfigurationID
WHERE ec.ExtractControlID = @ExtractControlID

INSERT INTO ExtractExecutionLog
(
	ExtractJobID,
	StartTime,
	EndTime,
	ManagerGUID,
	SuccessFlag,
	CompletedFlag,
	MessageSource,
	Message,
	RowsExtracted,
	ExtractPackagePathAndName,
	ExtractPackageName,
	ExtractPackagePath,
	SourceControlID,
	SourceControlValue,
	DestinationControlID,
	DestinationControlValue,
	SuiteID,
	SuiteName,
	ExecutionOrder,
	ExtractStartTime,
	ExtractEndTime,
	NextExtractStartTime,
	ExtractControlID
)
VALUES
(
	@ExtractJobID,
	@StartTime,
	GETDATE(),
	@ManagerGUID,
	@SuccessFlag,
	@CompletedFlag,
	@MessageSource,
	@Message,
	@RowsExtracted,
	@ExtractPackagePathAndName,
	@ExtractPackageName,
	@ExtractPackagePath,
	@SourceControlID,
	@SourceControlValue,
	@DestinationControlID,
	@DestinationControlValue,
	@SuiteID,
	@SuiteName,
	@ExecutionOrder,
	@ExtractStartTime,
	@ExtractEndTime,
	@NextExtractStartTime,
	@ExtractControlID
)

IF @SuccessFlag = 1 AND @CompletedFlag = 1
BEGIN
	UPDATE ExtractControl
	SET ExtractStartTime = @NextExtractStartTime, LastExtractJobID = @ExtractJobID
	WHERE ExtractControlID = @ExtractControlID
	EXEC spUpdateExtractExecutionStatus @ExtractControlID, 'S'
END
ELSE IF @SuccessFlag = 0 AND @CompletedFlag = 1
BEGIN
	EXEC spUpdateExtractExecutionStatus @ExtractControlID, 'F'
END
END
GO
PRINT N'Creating [dbo].[spGetStagingExecutionStandardVariables]...';


GO

CREATE PROCEDURE [dbo].[spGetStagingExecutionStandardVariables]
	@StagingControlID INT
AS
BEGIN
SET NOCOUNT ON;
-------------------------------------------------------------------------------
-- Set Status
-------------------------------------------------------------------------------
EXEC [spUpdateStagingExecutionStatus] @StagingControlID, 'P'
-------------------------------------------------------------------------------
-- Retrieve values
-------------------------------------------------------------------------------
SELECT
COALESCE(sc.StagingPackageName,'') AS 'StagingPackageName',
COALESCE(s.SuiteName, '') AS 'Suite',
CONVERT(CHAR(23), COALESCE(LastExecutionTime,'1900-01-01'), 121) AS 'ExtractStartTime',
COALESCE(sc.StagingPackagePath,'') AS 'StagingPackagePath',
COALESCE(sc.StagingTable,'') AS 'StagingTable',
COALESCE(dbo.udfPackagePathName(scEnv.ConfiguredValue, sc.StagingPackagePath, sc.StagingPackageName), '') AS 'StagingPathAndName',
COALESCE(scEnv.ConfiguredValue,'') AS 'Environment',
COALESCE(scSrv.ConfiguredValue,'') AS 'Server',
COALESCE(scMSDB.ConfiguredValue,'') AS 'ConnStr_msdb',
COALESCE(sc.ProcessType,'') AS 'ProcessType',
COALESCE(sc.SourceQuery,'') AS 'SourceQuery',
COALESCE(sc.SourceQueryMapping,'') AS 'SourceQueryMapping',
COALESCE(sc.MergeQuery,'') AS 'MergeQuery',
COALESCE(scBup.ConfiguredValue, '') AS 'BulkUploadLoadSize',
ISNULL(sc.TruncateStagingTable,0) AS 'TruncateStagingTable'
FROM dbo.StagingControl sc 
INNER JOIN dbo.Suite s ON sc.SuiteID = s.SuiteID
INNER JOIN dbo.SSISConfiguration scEnv ON scEnv.ConfigurationFilter = 'Environment'
INNER JOIN dbo.SSISConfiguration scSrv ON scSrv.ConfigurationFilter = 'Server'
INNER JOIN dbo.SSISConfiguration scMSDB ON scMSDB.ConfigurationFilter = 'ConnStr_msdb'
INNER JOIN dbo.SSISConfiguration scBup ON scBup.ConfigurationFilter = 'BulkUploadLoadSize'
WHERE sc.StagingControlID = @StagingControlID
END
GO
PRINT N'Creating [dbo].[spInsertStagingExecutionLog]...';


GO


CREATE PROCEDURE [dbo].[spInsertStagingExecutionLog]
	@StagingJobID INT,
    @StartTime VARCHAR(50),
	@ManagerGUID UNIQUEIDENTIFIER,
    @SuccessFlag INT,
    @CompletedFlag INT,
    @MessageSource VARCHAR(1000),
    @Message VARCHAR(MAX),
    @RowsStaged INT,
	@RowsInserted INT,
	@RowsDeleted INT,
	@RowsUpdated INT,
	@StagingPackagePathAndName VARCHAR(250),
	@ActualFileName VARCHAR(200),
	@ExtractStartTime DATETIME,
	@ExtractEndTime DATETIME,
    @StagingControlID INT
AS
BEGIN
	SET NOCOUNT ON;

DECLARE @StagingPackageName VARCHAR(50)
DECLARE @StagingPackagePath VARCHAR(200)
DECLARE @SourceControlID INT
DECLARE @SourceControlValue VARCHAR(255)
DECLARE @StagingDestControlID INT
DECLARE @StagingDestControlValue VARCHAR(255)
DECLARE @SuiteID INT
DECLARE @SuiteName VARCHAR(50)
DECLARE @RunAs32Bit VARCHAR(50)


SELECT 	@StagingPackageName = sc.StagingPackageName,
@StagingPackagePath = sc.StagingPackagePath,
@SourceControlID = sc.SourceControlID,
@SourceControlValue = SourceSSC.ConfiguredValue,
@StagingDestControlID = sc.StagingDestControlID,
@StagingDestControlValue = StagingSSC.ConfiguredValue,
@SuiteID = sc.SuiteID,
@SuiteName = s.SuiteName,
@RunAs32Bit = sc.RunAs32Bit
FROM dbo.StagingControl sc
LEFT JOIN dbo.Suite s ON sc.SuiteID = s.SuiteID
INNER JOIN dbo.SourceControl SourceSC ON sc.SourceControlID = SourceSC.SourceControlID
INNER JOIN dbo.SSISConfiguration SourceSSC ON SourceSC.SSISConfigurationID = SourceSSC.SSISConfigurationID
INNER JOIN dbo.SourceControl StagingSC ON sc.StagingDestControlID = StagingSC.SourceControlID
INNER JOIN dbo.SSISConfiguration StagingSSC ON StagingSC.SSISConfigurationID = StagingSSC.SSISConfigurationID
WHERE sc.StagingControlID = @StagingControlID

INSERT INTO StagingExecutionLog
(
	StagingJobID,
	StartTime,
	EndTime,
	ManagerGUID,
	SuccessFlag,
	CompletedFlag,
	MessageSource,
	Message,
	RowsStaged,
	RowsInserted,
	RowsDeleted,
	RowsUpdated,
	StagingControlID,
	StagingPackagePathAndName,
	StagingPackageName,
	StagingPackagePath,
	ActualFileName,
	SourceControlID,
	SourceControlValue,
	StagingDestControlID,
	StagingDestControlValue,
	SuiteID,
	SuiteName,
	RunAs32Bit,
	ExtractStartTime,
	ExtractEndTime	
)
VALUES
(
	@StagingJobID,
	@StartTime,
	GETDATE(),
	@ManagerGUID,
	@SuccessFlag,
	@CompletedFlag,
	@MessageSource,
	@Message,
	@RowsStaged,
	@RowsInserted,
	@RowsDeleted,
	@RowsUpdated,
	@StagingControlID,
	@StagingPackagePathAndName,
	@StagingPackageName,
	@StagingPackagePath,
	@ActualFileName,
	@SourceControlID,
	@SourceControlValue,
	@StagingDestControlID,
	@StagingDestControlValue,
	@SuiteID,
	@SuiteName,
	@RunAs32Bit,
	@ExtractStartTime,
	@ExtractEndTime
)

IF @ActualFileName IS NOT NULL OR LEN(@ActualFileName)> 0
BEGIN
	UPDATE [dbo].[StagingControl] SET [LastProcessedTime] = GETDATE()  WHERE [StagingControlID] = @StagingControlID
END

IF @SuccessFlag = 1 AND @CompletedFlag = 1
BEGIN
	UPDATE StagingControl
	SET LastExecutionTime = @ExtractEndTime, LastStagingJobID = @StagingJobID
	WHERE StagingControlID = @StagingControlID
	EXEC spUpdateStagingExecutionStatus @StagingControlID, 'S'
END
ELSE IF @SuccessFlag = 0 AND @CompletedFlag = 1
BEGIN
	EXEC spUpdateStagingExecutionStatus @StagingControlID, 'F'
END

END
GO
PRINT N'Creating [Audit_DDL]...';


GO
		CREATE TRIGGER Audit_DDL 
		ON DATABASE 
		FOR DDL_DATABASE_LEVEL_EVENTS
		AS 
		
			DECLARE @DynamicSQL AS NVARCHAR(MAX);			
			DECLARE @event XML;
			SET @event = EVENTDATA();

			DECLARE	
				@DDL_Event_Time AS DATETIME = REPLACE(CONVERT(NVARCHAR(50), @event.query('data(/EVENT_INSTANCE/PostTime)')), 'T', ' ')
				,@DDL_Login_Name AS NVARCHAR(150) = CONVERT(NVARCHAR(150), @event.query('data(/EVENT_INSTANCE/LoginName)'))
				,@DDL_User_Name AS NVARCHAR(150) = CONVERT(NVARCHAR(150), @event.query('data(/EVENT_INSTANCE/UserName)'))
				,@DDL_Server_Name AS NVARCHAR(150) = CONVERT(NVARCHAR(150), @event.query('data(/EVENT_INSTANCE/ServerName)'))
				,@DDL_Database_Name AS NVARCHAR(150) = CONVERT(NVARCHAR(150), @event.query('data(/EVENT_INSTANCE/DatabaseName)'))
				,@DDL_Schema_Name AS NVARCHAR(150) = CONVERT(NVARCHAR(150), @event.query('data(/EVENT_INSTANCE/SchemaName)'))
				,@DDL_Object_Name AS NVARCHAR(150) = CONVERT(NVARCHAR(150), @event.query('data(/EVENT_INSTANCE/ObjectName)'))
				,@DDL_Object_Type AS NVARCHAR(150) = CONVERT(NVARCHAR(150), @event.query('data(/EVENT_INSTANCE/ObjectType)'))
				,@DDL_Command AS NVARCHAR(max) = CONVERT(NVARCHAR(max), @event.query('data(/EVENT_INSTANCE/TSQLCommand/CommandText)'))
				,@DDL_CreateCommand AS NVARCHAR(max) = ''

			INSERT INTO Audit.Audit_DDL_Events
			VALUES (
				@DDL_Event_Time
				,@DDL_Login_Name
				,@DDL_User_Name
				,@DDL_Server_Name
				,@DDL_Database_Name
				,@DDL_Schema_Name
				,@DDL_Object_Name
				,@DDL_Object_Type
				,@DDL_Command
				,@DDL_CreateCommand
				);
GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET MULTI_USER 
    WITH ROLLBACK IMMEDIATE;


GO
PRINT N'Update complete.';


GO
